{"id":"translatorvoiceinputtool-13v","title":"M1: Sidecar MVP","description":"MILESTONE M1 (Day 1-3): Reliable audio capture + model management + transcription + notifications.\n\n## PURPOSE\nBuild the complete Python sidecar that handles all audio/ASR/text-processing responsibilities. This runs in parallel with M2 (Rust Core) but must be coordinate via the locked IPC contract from M0.\n\n## KEY DELIVERABLES\n- JSON-RPC 2.0 server loop with robust error handling\n- Device enumeration with stable UIDs\n- Audio recorder with bounded memory\n- Audio preprocessing (downmix, resample, normalize, silence trim)\n- Model cache management (download, verify, purge with locking)\n- ASR backend (Parakeet) with CPU baseline and optional CUDA\n- Postprocess + replacements + macros pipeline\n- All required notifications (status, completion, errors, audio meter)\n\n## ARCHITECTURE CONTEXT\nThe sidecar communicates via NDJSON (newline-delimited JSON) over stdin/stdout. It is spawned and supervised by Rust. All state decisions remain with Rust; the sidecar is a \"worker\" that executes commands and emits events.\n\n## DEPENDENCIES\n- Requires M0 IPC contract lock before starting protocol implementation\n- M0.6 sidecar packaging spike should inform ML dependency decisions\n\n## PARALLEL WORK\nCan proceed in parallel with M2 once M0 gate is passed, using mock/stub implementations on either side as needed.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-02-04T03:02:12.398254589Z","created_by":"ubuntu","updated_at":"2026-02-04T03:02:12.398254589Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"translatorvoiceinputtool-13v.1","title":"M1.1: JSON-RPC server loop with robust error handling","description":"Implement the main RPC server loop with proper JSON-RPC 2.0 compliance.\n\n## ACCEPTANCE CRITERIA\n- Unknown method → JSON-RPC error with numeric code -32601 and data.kind=E_METHOD_NOT_FOUND\n- Invalid payload → error with data.kind=E_INVALID_PARAMS\n- Malformed JSON line → error response without crashing\n- EOF → clean shutdown (exit 0)\n- NDJSON flush-after-each-message enforced\n- Tests simulate partial reads (lines split across buffers)\n- Tests simulate oversized lines (>1 MiB) → handled gracefully\n\n## IMPLEMENTATION DETAILS\nFile: sidecar/src/openvoicy_sidecar/server.py\n\nMain loop pattern:\n1. Read line from stdin\n2. Parse JSON\n3. Validate JSON-RPC structure\n4. Dispatch to method handler\n5. Send response (or notification)\n6. Flush stdout\n\nError handling:\n- JSON parse error → error response with id=null\n- Missing required fields → E_INVALID_PARAMS\n- Unknown method → E_METHOD_NOT_FOUND\n- Handler exception → E_INTERNAL with safe message\n\n## JSON-RPC 2.0 ERROR CODES\n-32700: Parse error\n-32600: Invalid Request\n-32601: Method not found\n-32602: Invalid params\n-32603: Internal error\n-32000 to -32099: Server error (our custom errors)\n\n## TEST CASES\n- Valid request → valid response\n- Malformed JSON → parse error response\n- Missing jsonrpc field → invalid request\n- Unknown method → method not found\n- Partial line buffering → correctly assembled\n- EOF → clean exit\n- Very long line → handled without OOM\n\n## WHY THIS MATTERS\nThe server loop is the foundation of all sidecar functionality. It must be rock-solid to enable reliable IPC.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-04T03:05:15.086917638Z","created_by":"ubuntu","updated_at":"2026-02-04T05:32:20.359457219Z","closed_at":"2026-02-04T05:32:20.359418338Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-13v.1","depends_on_id":"translatorvoiceinputtool-13v","type":"parent-child","created_at":"2026-02-04T03:05:15.086917638Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.1","depends_on_id":"translatorvoiceinputtool-1ao.2","type":"blocks","created_at":"2026-02-04T03:19:24.121962112Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.1","depends_on_id":"translatorvoiceinputtool-1ao.3","type":"blocks","created_at":"2026-02-04T03:19:24.230992632Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-13v.2","title":"M1.2: Device enumeration + set device with stable UIDs","description":"Implement audio device listing and selection using stable identifiers.\n\n## ACCEPTANCE CRITERIA\n- audio.list_devices returns device list with stable UIDs\n- Handles no-devices-available gracefully (empty list, not error)\n- UIDs are stable across sidecar restarts (best-effort, OS-provided)\n- audio.set_device accepts device_uid string\n- Invalid UID → E_DEVICE_NOT_FOUND error\n- Device reconnect → UID remains consistent\n\n## API SHAPES\n\n### audio.list_devices → response\n{\n  \"devices\": [\n    {\n      \"uid\": \"hw:0,0\",  // or GUID on Windows\n      \"name\": \"Built-in Microphone\",\n      \"is_default\": true,\n      \"default_sample_rate\": 48000,\n      \"channels\": 2\n    }\n  ]\n}\n\n### audio.set_device { device_uid: string|null } → response\n{\n  \"active_device_uid\": \"hw:0,0\"\n}\n\n## IMPLEMENTATION NOTES\nFile: sidecar/src/openvoicy_sidecar/audio.py\n\n- Use sounddevice library for cross-platform audio\n- On Linux: ALSA/PulseAudio device names\n- On macOS: CoreAudio device UIDs\n- On Windows: WASAPI device GUIDs\n- Prefer persistent identifiers over numeric indices\n- Numeric indices change across restarts!\n\n## STABLE UID STRATEGY\n- Linux: Use ALSA hw: identifiers or PulseAudio device names\n- macOS: Use CoreAudio UID property\n- Windows: Use WASAPI device endpoint ID\n\n## EDGE CASES\n- Hot-plug: device appears/disappears between list and set\n- Multiple devices with same name: UID distinguishes\n- Default device changes: track is_default flag\n- Permission denied: E_MIC_PERMISSION with remediation\n\n## TEST REQUIREMENTS\n- Unit test: returns empty list when no devices (not error)\n- Unit test: handles permission denial gracefully\n- Unit test: stable UID persistence simulation (mock device reconnect)\n- Unit test: invalid UID returns E_DEVICE_NOT_FOUND\n- Unit test: set_device with null selects default\n- Unit test: hot-plug scenario (device disappears after list, before set)\n- Integration test: actual device enumeration on CI (where available)\n\n## WHY THIS MATTERS\nUsers expect their microphone selection to persist across app restarts. Using numeric indices would reset selection every time.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:05:31.914680019Z","created_by":"ubuntu","updated_at":"2026-02-04T04:39:07.451910775Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-13v.2","depends_on_id":"translatorvoiceinputtool-13v","type":"parent-child","created_at":"2026-02-04T03:05:31.914680019Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.2","depends_on_id":"translatorvoiceinputtool-13v.1","type":"blocks","created_at":"2026-02-04T03:19:24.330932693Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-13v.3","title":"M1.3: Audio recorder with bounded memory","description":"Implement audio recording with memory limits and proper error handling.\n\n## ACCEPTANCE CRITERIA\n- recording.start begins capture\n- recording.stop ends capture and returns audio_duration_ms\n- recording.cancel discards buffered audio, emits no transcription event\n- Multiple start/stop cycles work correctly\n- Buffer memory is capped (no unbounded growth)\n- Device disconnect during recording → E_AUDIO_IO error\n- Capture at device native rate/channels\n- Convert to 16kHz mono float32 for ASR input\n\n## API SHAPES\n\n### recording.start { session_id: string, device_uid?: string } → response\n{\n  \"session_id\": \"uuid-from-rust\"\n}\nNote: Sidecar MUST echo the session_id and use it for all subsequent notifications.\n\n### recording.stop { session_id: string } → response\n{\n  \"audio_duration_ms\": 3500\n}\nNote: Must return quickly (<250ms). Transcription happens asynchronously.\n\n### recording.cancel { session_id: string } → response\n{\n  \"status\": \"cancelled\"\n}\nNote: MUST discard buffered audio. MUST NOT emit event.transcription_complete or event.transcription_error for this session.\n\n## IMPLEMENTATION NOTES\nFile: sidecar/src/openvoicy_sidecar/audio.py\n\nRecording strategy:\n1. Start callback-based stream on device\n2. Accumulate samples in ring buffer\n3. Cap buffer at max_duration (default 60s, hard cap 300s)\n4. On stop, return accumulated samples and trigger async transcription\n5. On cancel, discard samples and clear session state\n\nMemory management:\n- Pre-allocate buffer for max expected duration\n- Ring buffer overwrites oldest samples if exceeded\n- Report actual captured duration (accounting for any truncation)\n\n## SAMPLE FORMAT\n- Input: whatever device provides (usually 16-bit int or float32)\n- Internal: float32 normalized to [-1, 1]\n- Output: 16kHz mono float32 for ASR\n\n## SESSION STATE TRACKING\n```python\nclass Recorder:\n    def __init__(self):\n        self.active_session: Optional[str] = None\n        self.buffer: np.ndarray = None\n        self.cancelled_sessions: set = set()  # Track cancelled sessions\n    \n    def start(self, session_id: str, device_uid: Optional[str] = None):\n        if self.active_session is not None:\n            raise RecordingInProgressError()\n        self.active_session = session_id\n        self.buffer = np.zeros(...)\n        self._start_capture(device_uid)\n    \n    def stop(self, session_id: str) -> int:\n        if self.active_session != session_id:\n            raise SessionMismatchError()\n        self._stop_capture()\n        duration_ms = self._calculate_duration()\n        # Trigger async transcription\n        asyncio.create_task(self._transcribe(session_id, self.buffer.copy()))\n        self.active_session = None\n        return duration_ms\n    \n    def cancel(self, session_id: str):\n        if self.active_session != session_id:\n            raise SessionMismatchError()\n        self._stop_capture()\n        self.cancelled_sessions.add(session_id)\n        self.buffer = None\n        self.active_session = None\n```\n\n## ERROR SCENARIOS\n- Device unplugged → callback receives error → emit E_AUDIO_IO\n- Permission revoked → detect and emit E_MIC_PERMISSION\n- Buffer overflow → truncate and note in metadata (don't error)\n- Session mismatch → return error response\n\n## THREAD SAFETY\n- Audio callback runs on separate thread\n- Use thread-safe queue or lock for sample handoff\n- Stop/cancel must wait for callback to complete (with timeout)\n\n## TEST REQUIREMENTS\n- Test start/stop cycle\n- Test start/cancel cycle (verify no transcription event)\n- Test multiple consecutive sessions\n- Test buffer memory limits\n- Test device disconnect handling\n- Test concurrent start rejection\n\n## WHY THIS MATTERS\nAudio capture is the input to everything else. Memory bounds prevent runaway memory usage on long recordings. Cancel support is essential for user experience (abort a mis-started recording).","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:06:00.339213286Z","created_by":"ubuntu","updated_at":"2026-02-04T03:43:05.915882218Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-13v.3","depends_on_id":"translatorvoiceinputtool-13v","type":"parent-child","created_at":"2026-02-04T03:06:00.339213286Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.3","depends_on_id":"translatorvoiceinputtool-13v.2","type":"blocks","created_at":"2026-02-04T03:19:24.448423488Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-13v.4","title":"M1.4: Audio preprocessing pipeline","description":"Implement deterministic audio preprocessing for ASR input.\n\n## ACCEPTANCE CRITERIA\n- Downmix stereo/multi-channel to mono (average channels)\n- Resample any input rate to 16kHz (required by ASR model)\n- DC offset removal (high-pass filter or mean subtraction)\n- Peak clamp to [-1, 1]\n- Optional peak normalization (default OFF for MVP)\n- Optional leading/trailing silence trim with energy threshold (default ON)\n- Output format: 16kHz mono float32 normalized to [-1, 1]\n- Golden tests verify deterministic output\n- Tests for resample + trim behavior with known inputs\n\n## PROCESSING PIPELINE ORDER (LOCKED)\n1. Convert to float32 if needed\n2. Downmix to mono (average channels)\n3. Resample to 16kHz\n4. DC offset removal (high-pass filter or mean subtraction)\n5. Peak clamp (saturate values outside [-1, 1])\n6. Optional: peak normalize (scale so max abs value = 1.0)\n7. Optional: silence trim (leading + trailing)\n\n## IMPLEMENTATION NOTES\nFile: sidecar/src/openvoicy_sidecar/preprocess.py\n\nLibraries:\n- librosa or scipy for resampling\n- numpy for array operations\n\nResampling:\n- Use high-quality resampler (polyphase filter)\n- 16kHz is standard for Parakeet and most speech models\n- Handle edge case: input already at 16kHz (no-op resample)\n\nSilence trimming:\n- Compute RMS energy in sliding windows (e.g., 20ms)\n- Default threshold: -40dB below peak\n- Keep some padding around speech (e.g., 100ms)\n- Configurable: enabled by default, threshold adjustable\n\n## CONFIGURATION\n- silence_trim_enabled: boolean (default true)\n- silence_threshold_db: float (default -40)\n- normalize_enabled: boolean (default false for MVP)\n\n## GOLDEN TEST APPROACH\nCreate reproducible test signals:\n1. Synthetic sine wave at known frequency → verify amplitude preserved\n2. Known impulse → verify timing preserved after resample\n3. Stereo with L/R difference → verify proper mono mix\n4. Audio with DC offset → verify removal\n5. Clipped audio → verify peak clamp\n6. Silence-padded speech → verify trim\n\nGolden output files checked into repo for comparison.\n\n## EDGE CASES\n- Very short audio (< 100ms): process normally, don't error\n- Very long audio (> 5 min): process in chunks if memory constrained\n- Silence-only audio: return empty or near-empty array (not error)\n- Already 16kHz mono: minimal processing (DC removal, clamp only)\n- Extremely high sample rate (192kHz): handle gracefully\n\n## TEST REQUIREMENTS\n- Unit test: downmix stereo to mono (verify average)\n- Unit test: downmix 5.1 to mono\n- Unit test: resample 44.1kHz to 16kHz\n- Unit test: resample 48kHz to 16kHz\n- Unit test: resample 16kHz (no-op, verify identical)\n- Unit test: DC offset removal\n- Unit test: peak clamp (audio with values > 1.0)\n- Unit test: silence trim (leading silence)\n- Unit test: silence trim (trailing silence)\n- Unit test: silence trim (both)\n- Unit test: silence trim disabled\n- Unit test: normalize enabled\n- Golden test: known input → expected output file comparison\n- Performance test: 60s audio processes in < 1s\n\n## OUTPUT SPECIFICATION\n- Sample rate: 16000 Hz (exactly)\n- Channels: 1 (mono)\n- Format: float32\n- Range: [-1.0, 1.0]\n- Dtype: numpy.float32\n\n## WHY THIS MATTERS\nConsistent preprocessing ensures reproducible ASR results. The model expects specific input format (16kHz mono float32). Inconsistent preprocessing would cause variable transcription quality.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:06:19.285397728Z","created_by":"ubuntu","updated_at":"2026-02-04T04:40:08.663639301Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-13v.4","depends_on_id":"translatorvoiceinputtool-13v","type":"parent-child","created_at":"2026-02-04T03:06:19.285397728Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.4","depends_on_id":"translatorvoiceinputtool-13v.3","type":"blocks","created_at":"2026-02-04T03:19:24.592350686Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-13v.5","title":"M1.5: Model cache + download/verify/purge","description":"Implement robust model cache management with download, verification, and cleanup.\n\n## ACCEPTANCE CRITERIA\n- model.get_status returns current model state\n- Deterministic cache location (OS cache directory)\n- Downloads are atomic: temp → verify → rename\n- Downloads resumable via HTTP Range when server supports\n- Mirror URL fallback when primary fails\n- Disk-space preflight before download\n- Cache lock prevents concurrent download/verify/purge\n- Manifest validation: file existence + size + SHA-256\n- Corrupted cache triggers controlled re-download\n- model.purge_cache clears and triggers re-download status\n\n## API SHAPES\n\n### model.get_status → response\n{\n  \"model_id\": \"parakeet-tdt-0.6b-v3\",\n  \"revision\": \"abc123\",\n  \"status\": \"ready\",  // missing|downloading|verifying|ready|error\n  \"progress\": { \"current\": 500000000, \"total\": 600000000, \"unit\": \"bytes\" },\n  \"cache_path\": \"/home/user/.cache/openvoicy/models/...\"\n}\n\n### model.purge_cache { model_id?: string } → response\n{\n  \"purged\": true\n}\n(Returns E_NOT_READY if model is currently in use)\n\n## CACHE DIRECTORY STRUCTURE\n~/.cache/openvoicy/models/\n  parakeet-tdt-0.6b-v3/\n    manifest.json     # copy of MODEL_MANIFEST.json at download time\n    model.onnx\n    vocab.json\n    ...\n\n## DOWNLOAD FLOW WITH MIRRORS\n1. Check disk space (need size + 10% buffer)\n2. Acquire process lock (file lock or lock file)\n3. Create temp directory\n4. For each file in manifest:\n   a. Try primary URL\n   b. If fails, try each mirror URL in order\n   c. Support HTTP Range for resume\n   d. Download to temp (resume if partial exists)\n   e. Verify: size + SHA-256\n5. All files verified → atomic rename temp → final\n6. Update status → ready\n7. Release lock\n\nMirror fallback logic:\n\\`\\`\\`python\nasync def download_file(file_info):\n    urls = [file_info.primary_url] + file_info.mirror_urls\n    last_error = None\n    for url in urls:\n        try:\n            await download_with_resume(url, file_info.path)\n            return\n        except NetworkError as e:\n            last_error = e\n            log.warning(f\"Failed to download from {url}, trying next mirror\")\n    raise last_error\n\\`\\`\\`\n\n## RESUMABLE DOWNLOADS\n\\`\\`\\`python\nasync def download_with_resume(url, path):\n    existing_size = path.stat().st_size if path.exists() else 0\n    headers = {}\n    if existing_size > 0:\n        headers['Range'] = f'bytes={existing_size}-'\n    \n    async with aiohttp.get(url, headers=headers) as resp:\n        if resp.status == 206:  # Partial content\n            mode = 'ab'  # Append\n        elif resp.status == 200:\n            mode = 'wb'  # Restart\n            existing_size = 0\n        else:\n            raise NetworkError(f\"Unexpected status {resp.status}\")\n        \n        total = existing_size + resp.content_length\n        with open(path, mode) as f:\n            async for chunk in resp.content.iter_chunked(8192):\n                f.write(chunk)\n                emit_progress(existing_size + f.tell(), total)\n\\`\\`\\`\n\n## DISK SPACE PREFLIGHT\n\\`\\`\\`python\ndef check_disk_space(required_bytes):\n    import shutil\n    cache_dir = get_cache_directory()\n    cache_dir.mkdir(parents=True, exist_ok=True)\n    \n    total, used, free = shutil.disk_usage(cache_dir)\n    needed = required_bytes * 1.1  # 10% buffer\n    \n    if free < needed:\n        raise DiskFullError(\n            required=needed,\n            available=free,\n            message=f\"Need {format_bytes(needed)}, only {format_bytes(free)} available\"\n        )\n\\`\\`\\`\n\n## ERROR HANDLING\n- E_DISK_FULL: include required_bytes in error details\n- E_NETWORK: network failure during download (all mirrors failed)\n- E_CACHE_CORRUPT: hash mismatch after download\n- Recovery: purge corrupt cache and retry\n\n## CONCURRENCY\n- File lock prevents multiple processes downloading simultaneously\n- Lock file: ~/.cache/openvoicy/models/.lock\n- Lock timeout: 10 minutes (for slow downloads)\n- Use fcntl.flock on Unix, msvcrt.locking on Windows\n\n## TEST REQUIREMENTS\n- Unit test: disk space check\n- Unit test: resumable download logic\n- Unit test: mirror fallback\n- Unit test: hash verification\n- Integration test: full download flow (mock server)\n- Test corrupt file detection and re-download\n- Test concurrent access with lock\n\n## WHY THIS MATTERS\nModel downloads are multi-GB operations. They must be reliable, resumable, and safe from corruption. Mirror support ensures availability.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:06:39.885624833Z","created_by":"ubuntu","updated_at":"2026-02-04T03:29:48.999975055Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-13v.5","depends_on_id":"translatorvoiceinputtool-13v","type":"parent-child","created_at":"2026-02-04T03:06:39.885624833Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.5","depends_on_id":"translatorvoiceinputtool-1ao.5","type":"blocks","created_at":"2026-02-04T03:19:34.196430167Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-13v.6","title":"M1.6: ASR initialization and inference","description":"Implement backend-abstracted ASR with CPU baseline and optional CUDA.\n\n## ACCEPTANCE CRITERIA\n- asr.initialize loads model once, idempotent fast path on subsequent calls\n- CPU-only baseline works on all systems\n- CUDA acceleration optional (auto-detect, not required)\n- Emits event.status_changed progress during download/init\n- Subsequent calls return within 250ms when already initialized\n- \"Offline after download\" invariant verified manually\n\n## API SHAPES\n\n### asr.initialize { model_id: string, device_pref: \"auto\"|\"cuda\"|\"cpu\" } → response\n{\n  \"status\": \"ready\",\n  \"model_id\": \"parakeet-tdt-0.6b-v3\",\n  \"device\": \"cpu\"  // or \"cuda\"\n}\n\n## IMPLEMENTATION NOTES\nFiles:\n- sidecar/src/openvoicy_sidecar/asr/__init__.py (backend selection)\n- sidecar/src/openvoicy_sidecar/asr/base.py (interface)\n- sidecar/src/openvoicy_sidecar/asr/parakeet.py (implementation)\n\nBackend interface:\n```python\nclass ASRBackend(Protocol):\n    def initialize(self, model_path: Path, device: str) -> None: ...\n    def transcribe(self, audio: np.ndarray) -> str: ...\n    def is_ready(self) -> bool: ...\n```\n\n## DEVICE SELECTION LOGIC\n1. If device_pref == \"cuda\": try CUDA, fail if unavailable\n2. If device_pref == \"cpu\": use CPU only\n3. If device_pref == \"auto\": try CUDA if available, fallback to CPU\n\n## INITIALIZATION FLOW\n1. Check if model cache is ready\n2. If not, trigger download (blocks with progress events)\n3. Load model into memory\n4. Run warmup inference (optional, for latency)\n5. Mark as ready\n\n## PROGRESS EVENTS\nDuring download:\nevent.status_changed { state: \"loading_model\", progress: { current: X, total: Y, unit: \"bytes\" } }\n\nDuring model load:\nevent.status_changed { state: \"loading_model\", detail: \"Loading model into memory...\" }\n\n## OFFLINE VERIFICATION\nManual test: disable network at OS level, confirm transcription succeeds with cached model.\n\n## WHY THIS MATTERS\nThis is the core ASR functionality. The abstraction allows swapping backends without changing Rust/UI code.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:06:59.224435830Z","created_by":"ubuntu","updated_at":"2026-02-04T03:19:34.381209455Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-13v.6","depends_on_id":"translatorvoiceinputtool-13v","type":"parent-child","created_at":"2026-02-04T03:06:59.224435830Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.6","depends_on_id":"translatorvoiceinputtool-13v.4","type":"blocks","created_at":"2026-02-04T03:19:34.282848836Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.6","depends_on_id":"translatorvoiceinputtool-13v.5","type":"blocks","created_at":"2026-02-04T03:19:34.381122204Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-13v.7","title":"M1.7: Postprocess + macros + replacements pipeline","description":"Implement text postprocessing with macro expansion and replacement rules.\n\n## ACCEPTANCE CRITERIA\n- Pipeline order is locked and enforced\n- Semantics validated by shared test vectors\n- Macros {{date}}/{{time}}/{{datetime}} work correctly (local timezone)\n- Preset rule sets loadable from shared/replacements/PRESETS.json\n- Presets labeled with origin=\"preset\" for UI distinction\n- Maximum 500 rules enforced (E_INVALID_PARAMS if exceeded)\n- Pattern max length 256, replacement max length 1024 enforced\n- Output max length 50,000 chars (truncate with warning category, not error)\n- All constraints validated on replacements.set_rules call\n\n## PIPELINE ORDER (LOCKED FOR MVP, SINGLE PASS)\n1. Postprocess normalization (cleanup, casing, spacing)\n2. Macro expansion ({{date}} etc.)\n3. Replacements apply-all in order (single pass, no recursion)\n\n**CRITICAL**: Single pass means if a replacement produces text containing another pattern, that pattern is NOT processed. This prevents infinite loops and makes behavior predictable.\n\n## IMPLEMENTATION NOTES\nFiles:\n- sidecar/src/openvoicy_sidecar/postprocess.py (normalization)\n- sidecar/src/openvoicy_sidecar/replacements.py (rules + macros)\n\n## POSTPROCESS NORMALIZATION\n- Normalize whitespace (collapse multiple spaces to single)\n- Fix common ASR artifacts (e.g., leading/trailing spaces)\n- Optional: capitalize first letter of sentences (configurable, default off for MVP)\n\n## MACRO EXPANSION\n- {{date}} → \"2026-02-04\" (local timezone, ISO format YYYY-MM-DD)\n- {{time}} → \"15:30\" (local timezone, 24h format HH:MM)\n- {{datetime}} → \"2026-02-04 15:30\" (local timezone, space-separated)\n- Macros are case-sensitive ({{DATE}} is not expanded)\n- Unknown macros pass through unchanged (no error)\n\n```python\nimport datetime\n\nMACROS = {\n    \"{{date}}\": lambda: datetime.date.today().isoformat(),\n    \"{{time}}\": lambda: datetime.datetime.now().strftime(\"%H:%M\"),\n    \"{{datetime}}\": lambda: datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M\"),\n}\n\ndef expand_macros(text: str) -> str:\n    result = text\n    for pattern, replacement_fn in MACROS.items():\n        result = result.replace(pattern, replacement_fn())\n    return result\n```\n\n## REPLACEMENT RULES SCHEMA\nReplacementRule schema (normative, matches shared/schema/ReplacementRule.schema.json):\n```python\n@dataclass\nclass ReplacementRule:\n    id: str              # UUID recommended\n    enabled: bool\n    kind: Literal[\"literal\", \"regex\"]\n    pattern: str         # non-empty, max 256 chars\n    replacement: str     # max 1024 chars\n    word_boundary: bool  # applies to literal only; ignored for regex\n    case_sensitive: bool\n    description: Optional[str] = None\n    origin: Optional[Literal[\"user\", \"preset\"]] = None\n```\n\n## CONSTRAINT VALIDATION\n```python\nMAX_RULES = 500\nMAX_PATTERN_LENGTH = 256\nMAX_REPLACEMENT_LENGTH = 1024\nMAX_OUTPUT_LENGTH = 50_000\n\ndef validate_rules(rules: list[ReplacementRule]) -> None:\n    if len(rules) > MAX_RULES:\n        raise ValueError(f\"Too many rules: {len(rules)} > {MAX_RULES}\")\n    \n    for i, rule in enumerate(rules):\n        if len(rule.pattern) > MAX_PATTERN_LENGTH:\n            raise ValueError(f\"Rule {i} pattern too long: {len(rule.pattern)} > {MAX_PATTERN_LENGTH}\")\n        if len(rule.replacement) > MAX_REPLACEMENT_LENGTH:\n            raise ValueError(f\"Rule {i} replacement too long: {len(rule.replacement)} > {MAX_REPLACEMENT_LENGTH}\")\n        if not rule.pattern:\n            raise ValueError(f\"Rule {i} pattern is empty\")\n        if rule.kind == \"regex\":\n            try:\n                re.compile(rule.pattern)\n            except re.error as e:\n                raise ValueError(f\"Rule {i} invalid regex: {e}\")\n```\n\n## OUTPUT TRUNCATION\n```python\ndef apply_replacements(text: str, rules: list[ReplacementRule]) -> tuple[str, bool]:\n    \"\"\"Returns (result, was_truncated)\"\"\"\n    result = text\n    for rule in rules:\n        if not rule.enabled:\n            continue\n        result = apply_single_rule(result, rule)\n    \n    truncated = False\n    if len(result) > MAX_OUTPUT_LENGTH:\n        result = result[:MAX_OUTPUT_LENGTH]\n        truncated = True\n        log.warning(f\"Output truncated to {MAX_OUTPUT_LENGTH} chars\")\n    \n    return result, truncated\n```\n\n## PRESETS LOADING AND MANAGEMENT\n\n### Preset File Location\nFile: shared/replacements/PRESETS.json\n\n### Preset File Format\n```json\n{\n  \"presets\": [\n    {\n      \"id\": \"common-abbreviations\",\n      \"name\": \"Common Abbreviations\",\n      \"description\": \"Expands common spoken abbreviations\",\n      \"rules\": [\n        {\n          \"id\": \"abbrev-btw\",\n          \"enabled\": true,\n          \"kind\": \"literal\",\n          \"pattern\": \"BTW\",\n          \"replacement\": \"by the way\",\n          \"word_boundary\": true,\n          \"case_sensitive\": false\n        }\n      ]\n    },\n    {\n      \"id\": \"punctuation-cleanup\",\n      \"name\": \"Punctuation\",\n      \"description\": \"Improves punctuation in transcripts\",\n      \"rules\": [ ... ]\n    }\n  ]\n}\n```\n\n### Preset Loading Flow\n1. On sidecar startup: load PRESETS.json from bundle/resources\n2. On replacements.set_rules call: rules may include preset rules (origin=\"preset\")\n3. Rust/UI decides which presets to enable (from config)\n4. UI shows preset rules as non-editable, user rules as editable\n\n### Preset Rule Identification\nPreset rules have:\n- origin: \"preset\"\n- id: prefixed with preset ID (e.g., \"common-abbreviations:btw\")\n\nUser rules have:\n- origin: \"user\" or null\n- id: user-generated UUID\n\n## EVALUATION SEMANTICS\n- Apply all enabled rules in order\n- Single pass (no recursion/chaining)\n- Literal + word_boundary: match whole words only (regex: \\bpattern\\b)\n- Regex: Python re module syntax\n- Disabled rules skipped entirely\n\n## LITERAL WITH WORD BOUNDARY\n```python\nimport re\n\ndef apply_literal_rule(text: str, rule: ReplacementRule) -> str:\n    if rule.word_boundary:\n        pattern = r'\\b' + re.escape(rule.pattern) + r'\\b'\n    else:\n        pattern = re.escape(rule.pattern)\n    \n    flags = 0 if rule.case_sensitive else re.IGNORECASE\n    return re.sub(pattern, rule.replacement, text, flags=flags)\n```\n\n## SHARED TEST VECTORS\nFile: shared/replacements/TEST_VECTORS.json\nBoth Python (sidecar) and TypeScript (UI preview) tests consume these vectors to ensure identical behavior.\n\n```json\n{\n  \"test_cases\": [\n    {\n      \"name\": \"simple literal replacement\",\n      \"input\": \"I said BTW yesterday\",\n      \"rules\": [\n        {\"id\": \"1\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"BTW\", \"replacement\": \"by the way\", \"word_boundary\": true, \"case_sensitive\": false}\n      ],\n      \"expected\": \"I said by the way yesterday\"\n    },\n    {\n      \"name\": \"macro expansion\",\n      \"input\": \"Meeting scheduled for {{date}}\",\n      \"rules\": [],\n      \"expected_pattern\": \"Meeting scheduled for \\\\d{4}-\\\\d{2}-\\\\d{2}\"\n    }\n  ]\n}\n```\n\n## ERROR HANDLING\n- validation errors in set_rules → E_INVALID_PARAMS with details\n- regex syntax errors → E_INVALID_PARAMS with pattern and error message\n- output truncation → success but log warning (not error to user)\n\n## TEST REQUIREMENTS\n- Unit test: each pipeline stage independently\n- Unit test: pipeline order enforced\n- Unit test: macro expansion with mocked time\n- Unit test: word boundary edge cases (punctuation, unicode)\n- Unit test: case sensitivity tests\n- Unit test: truncation behavior test\n- Unit test: max rules enforcement test\n- Unit test: invalid regex detection test\n- Unit test: disabled rules skipped\n- Unit test: preset loading from JSON\n- Unit test: preset origin preserved\n- Shared test vector validation\n- Performance test: 500 rules in < 100ms\n\n## WHY THIS MATTERS\nText transformation is a core feature. Shared test vectors prevent drift between sidecar (actual processing) and UI (preview). Constraints protect against abuse and ensure predictable performance.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:07:16.752112555Z","created_by":"ubuntu","updated_at":"2026-02-04T04:43:53.005339999Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-13v.7","depends_on_id":"translatorvoiceinputtool-13v","type":"parent-child","created_at":"2026-02-04T03:07:16.752112555Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.7","depends_on_id":"translatorvoiceinputtool-13v.1","type":"blocks","created_at":"2026-02-04T03:19:34.494765434Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-13v.8","title":"M1.8: Notifications for status + completion/errors + audio meter","description":"Implement all notification types for Rust communication.\n\n## ACCEPTANCE CRITERIA\n- Exactly one completion OR error notification per session_id that reaches stop\n- recording.stop returns quickly (<250ms); transcription happens async\n- audio.meter_start emits event.audio_level at requested cadence with source=\"meter\"\n- audio.meter_stop correctly stops level events\n- During recording: emit event.audio_level with source=\"recording\" and session_id\n- Status changes emit event.status_changed appropriately\n- Progress events include cumulative bytes for downloads\n\n## NOTIFICATION SHAPES\n\n### event.status_changed\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"event.status_changed\",\n  \"params\": {\n    \"state\": \"recording\",  // idle|loading_model|recording|transcribing|error\n    \"detail\": \"Recording audio...\",\n    \"progress\": { \"current\": 100, \"total\": 1000, \"unit\": \"bytes\" },\n    \"model\": { \"model_id\": \"...\", \"status\": \"ready\" }\n  }\n}\n\n### event.audio_level\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"event.audio_level\",\n  \"params\": {\n    \"source\": \"meter\",      // \"meter\" for standalone test, \"recording\" during active recording\n    \"session_id\": \"...\",    // REQUIRED when source=\"recording\", absent for \"meter\"\n    \"rms\": 0.15,            // normalized 0..1\n    \"peak\": 0.42            // normalized 0..1\n  }\n}\n\nNote: During active recording, level events should have source=\"recording\" so UI can distinguish:\n- source=\"meter\": user testing mic in settings\n- source=\"recording\": live audio level during transcription\n\n### event.transcription_complete\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"event.transcription_complete\",\n  \"params\": {\n    \"session_id\": \"uuid-from-rust\",\n    \"text\": \"Hello world\",           // Post-processed and replacements-applied\n    \"confidence\": 0.95,               // optional, 0-1 if model provides it\n    \"duration_ms\": 250                // transcription compute time (not audio duration)\n  }\n}\n\n### event.transcription_error\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"event.transcription_error\",\n  \"params\": {\n    \"session_id\": \"uuid-from-rust\",\n    \"kind\": \"E_TRANSCRIBE\",           // stable error kind\n    \"message\": \"Failed to transcribe audio\"\n  }\n}\n\n## AUDIO METER IMPLEMENTATION\n- audio.meter_start { device_uid?, interval_ms? }\n- Default interval: 80ms (clamp 30-250ms as per protocol)\n- Must be low-CPU (no ASR/model load required)\n- Calculate RMS and peak from recent samples (e.g., last 100ms window)\n- Stop cleanly on audio.meter_stop\n- Meter can run while model is loading (for mic test during setup)\n\n```python\nclass AudioMeter:\n    def __init__(self):\n        self.running = False\n        self.stream = None\n    \n    async def start(self, device_uid: Optional[str], interval_ms: int = 80):\n        interval_ms = max(30, min(250, interval_ms))  # Clamp\n        self.running = True\n        self.stream = open_audio_stream(device_uid, callback=self._on_audio)\n        while self.running:\n            await asyncio.sleep(interval_ms / 1000)\n            self._emit_level()\n    \n    def _on_audio(self, data):\n        self.buffer = data  # Ring buffer of recent samples\n    \n    def _emit_level(self):\n        rms, peak = calculate_levels(self.buffer)\n        emit_notification(\"event.audio_level\", {\n            \"source\": \"meter\",\n            \"rms\": rms,\n            \"peak\": peak\n        })\n    \n    def stop(self):\n        self.running = False\n        if self.stream:\n            self.stream.close()\n```\n\n## AUDIO LEVELS DURING RECORDING\nWhen recording is active, emit levels with session_id:\n\n```python\nclass Recorder:\n    async def _recording_loop(self, session_id: str):\n        while self.recording:\n            # ... capture audio ...\n            rms, peak = calculate_levels(self.recent_samples)\n            emit_notification(\"event.audio_level\", {\n                \"source\": \"recording\",\n                \"session_id\": session_id,\n                \"rms\": rms,\n                \"peak\": peak\n            })\n            await asyncio.sleep(0.08)  # ~80ms interval\n```\n\n## ASYNC TRANSCRIPTION FLOW\n1. recording.stop returns immediately with audio_duration_ms\n2. In background: preprocess → ASR → postprocess → replacements\n3. Emit event.transcription_complete OR event.transcription_error\n4. Never emit both for same session_id\n5. Never emit notification for cancelled sessions\n\n## EXACTLY-ONCE SEMANTICS\n```python\nclass SessionTracker:\n    def __init__(self):\n        self.completed_sessions: set[str] = set()\n        self.cancelled_sessions: set[str] = set()\n    \n    def mark_completed(self, session_id: str):\n        if session_id in self.completed_sessions or session_id in self.cancelled_sessions:\n            return False  # Already handled\n        self.completed_sessions.add(session_id)\n        return True\n    \n    def mark_cancelled(self, session_id: str):\n        self.cancelled_sessions.add(session_id)\n    \n    def should_emit(self, session_id: str) -> bool:\n        return session_id not in self.completed_sessions and session_id not in self.cancelled_sessions\n    \n    def cleanup_old(self, max_age_seconds: int = 300):\n        # Periodically clean up old session tracking to prevent memory growth\n        pass\n```\n\n## PROGRESS EVENTS FOR MODEL DOWNLOAD\nDuring model download, emit cumulative progress:\n\n```python\nasync def download_with_progress(file_info, emit_fn):\n    downloaded = 0\n    total = file_info.size_bytes\n    \n    async for chunk in download_chunks(file_info.url):\n        downloaded += len(chunk)\n        emit_fn(\"event.status_changed\", {\n            \"state\": \"loading_model\",\n            \"detail\": f\"Downloading {file_info.name}...\",\n            \"progress\": {\n                \"current\": downloaded,\n                \"total\": total,\n                \"unit\": \"bytes\"\n            }\n        })\n```\n\n## TEST REQUIREMENTS\n- Unit test: exactly one completion per session\n- Unit test: exactly one error per session (not both)\n- Unit test: cancelled session emits nothing\n- Unit test: meter start/stop cadence\n- Unit test: meter levels are normalized 0-1\n- Unit test: recording levels include session_id\n- Unit test: progress events are cumulative\n- Unit test: duplicate completion/error rejected\n- Integration test: full recording → transcription → notification flow\n\n## WHY THIS MATTERS\nNotifications are how sidecar communicates state back to Rust. Reliable exactly-once delivery prevents duplicate injections. The source field for audio levels lets UI distinguish testing vs recording.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:07:36.208843674Z","created_by":"ubuntu","updated_at":"2026-02-04T04:41:26.874917065Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-13v.8","depends_on_id":"translatorvoiceinputtool-13v","type":"parent-child","created_at":"2026-02-04T03:07:36.208843674Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.8","depends_on_id":"translatorvoiceinputtool-13v.6","type":"blocks","created_at":"2026-02-04T03:19:34.608843553Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.8","depends_on_id":"translatorvoiceinputtool-13v.7","type":"blocks","created_at":"2026-02-04T03:19:34.744382440Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-13v.9","title":"Sidecar unit tests","description":"Implement comprehensive unit tests for sidecar Python code.\n\n## ACCEPTANCE CRITERIA\n- All core modules have unit test coverage\n- Tests run on all platforms\n- Golden tests for audio preprocessing\n- Shared test vectors consumed\n- CI runs pytest on every PR\n- No flaky tests\n\n## TEST FILES\n- sidecar/tests/test_protocol.py: JSON-RPC parsing, error responses\n- sidecar/tests/test_preprocess.py: audio preprocessing golden tests\n- sidecar/tests/test_postprocess.py: text normalization\n- sidecar/tests/test_replacements.py: rule application, shared test vectors\n- sidecar/tests/test_model_cache.py: download, verify, purge logic\n- sidecar/tests/test_meter.py: audio level calculation\n\n## PROTOCOL TESTS\n\\`\\`\\`python\n# sidecar/tests/test_protocol.py\nimport pytest\nfrom openvoicy_sidecar.protocol import parse_message, format_response\n\ndef test_parse_valid_request():\n    msg = '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"system.ping\",\"params\":{}}'\n    parsed = parse_message(msg)\n    assert parsed.method == \"system.ping\"\n    assert parsed.id == 1\n\ndef test_parse_malformed_json():\n    with pytest.raises(ValueError):\n        parse_message(\"not json\")\n\ndef test_parse_missing_jsonrpc():\n    with pytest.raises(ValueError):\n        parse_message('{\"id\":1,\"method\":\"test\"}')\n\ndef test_format_success_response():\n    resp = format_response(1, result={\"status\": \"ok\"})\n    assert resp[\"jsonrpc\"] == \"2.0\"\n    assert resp[\"id\"] == 1\n    assert resp[\"result\"][\"status\"] == \"ok\"\n    assert \"error\" not in resp\n\ndef test_format_error_response():\n    resp = format_response(1, error_code=-32601, error_message=\"Method not found\", error_kind=\"E_METHOD_NOT_FOUND\")\n    assert resp[\"error\"][\"code\"] == -32601\n    assert resp[\"error\"][\"data\"][\"kind\"] == \"E_METHOD_NOT_FOUND\"\n\\`\\`\\`\n\n## PREPROCESSING TESTS\n\\`\\`\\`python\n# sidecar/tests/test_preprocess.py\nimport numpy as np\nimport pytest\nfrom openvoicy_sidecar.preprocess import preprocess_audio\n\ndef test_downmix_stereo():\n    stereo = np.array([[1.0, 0.0], [0.5, 0.5], [0.0, 1.0]], dtype=np.float32)\n    mono = preprocess_audio(stereo, sample_rate=16000, target_rate=16000)\n    assert mono.ndim == 1\n    np.testing.assert_array_almost_equal(mono, [0.5, 0.5, 0.5])\n\ndef test_resample_48k_to_16k():\n    # 48kHz sine wave, 1 second\n    t = np.linspace(0, 1, 48000, dtype=np.float32)\n    audio_48k = np.sin(2 * np.pi * 440 * t)  # 440 Hz tone\n    \n    audio_16k = preprocess_audio(audio_48k, sample_rate=48000, target_rate=16000)\n    \n    assert len(audio_16k) == 16000  # 1 second at 16kHz\n    # Verify frequency content preserved (basic check)\n    assert np.max(np.abs(audio_16k)) > 0.9\n\ndef test_silence_trim():\n    # Audio with silence padding\n    silence = np.zeros(1600, dtype=np.float32)  # 100ms silence\n    speech = np.random.randn(8000).astype(np.float32) * 0.5\n    audio = np.concatenate([silence, speech, silence])\n    \n    trimmed = preprocess_audio(audio, sample_rate=16000, target_rate=16000, trim_silence=True)\n    \n    # Should be shorter than original\n    assert len(trimmed) < len(audio)\n\ndef test_dc_offset_removal():\n    # Audio with DC offset\n    audio = np.ones(1000, dtype=np.float32) * 0.5 + np.random.randn(1000).astype(np.float32) * 0.1\n    \n    processed = preprocess_audio(audio, sample_rate=16000, target_rate=16000)\n    \n    # Mean should be near zero\n    assert abs(np.mean(processed)) < 0.01\n\\`\\`\\`\n\n## REPLACEMENT TESTS (using shared vectors)\n\\`\\`\\`python\n# sidecar/tests/test_replacements.py\nimport json\nimport pytest\nimport re\nfrom pathlib import Path\nfrom openvoicy_sidecar.replacements import apply_replacements, expand_macros\n\n@pytest.fixture\ndef test_vectors():\n    path = Path(__file__).parent.parent.parent.parent / \"shared/replacements/TEST_VECTORS.json\"\n    with open(path) as f:\n        return json.load(f)[\"test_cases\"]\n\ndef test_shared_vectors(test_vectors):\n    for case in test_vectors:\n        result = apply_replacements(case[\"input\"], case[\"rules\"])\n        \n        if \"expected\" in case:\n            assert result == case[\"expected\"], f\"Failed: {case['name']}\"\n        elif \"expected_pattern\" in case:\n            assert re.match(case[\"expected_pattern\"], result), f\"Pattern mismatch: {case['name']}\"\n\ndef test_macro_date():\n    result = expand_macros(\"Today is {{date}}\")\n    assert re.match(r\"Today is \\d{4}-\\d{2}-\\d{2}\", result)\n\ndef test_macro_unknown_passthrough():\n    result = expand_macros(\"Hello {{unknown}}\")\n    assert result == \"Hello {{unknown}}\"\n\ndef test_disabled_rule_skipped():\n    rules = [{\"id\": \"1\", \"enabled\": False, \"kind\": \"literal\", \"pattern\": \"foo\", \"replacement\": \"bar\", \"word_boundary\": False, \"case_sensitive\": False}]\n    result = apply_replacements(\"foo\", rules)\n    assert result == \"foo\"\n\ndef test_max_rules_enforced():\n    rules = [{\"id\": str(i), \"enabled\": True, \"kind\": \"literal\", \"pattern\": \"x\", \"replacement\": \"y\", \"word_boundary\": False, \"case_sensitive\": False} for i in range(600)]\n    with pytest.raises(ValueError, match=\"500\"):\n        apply_replacements(\"test\", rules)\n\\`\\`\\`\n\n## MODEL CACHE TESTS\n\\`\\`\\`python\n# sidecar/tests/test_model_cache.py\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom openvoicy_sidecar.model import ModelCache, check_disk_space\n\ndef test_disk_space_check_sufficient():\n    with patch('shutil.disk_usage', return_value=(100e9, 50e9, 50e9)):\n        check_disk_space(1e9)  # Should not raise\n\ndef test_disk_space_check_insufficient():\n    with patch('shutil.disk_usage', return_value=(100e9, 99e9, 1e9)):\n        with pytest.raises(Exception, match=\"disk\"):\n            check_disk_space(10e9)\n\ndef test_hash_verification():\n    import hashlib\n    import tempfile\n    \n    content = b\"test content\"\n    expected_hash = hashlib.sha256(content).hexdigest()\n    \n    with tempfile.NamedTemporaryFile(delete=False) as f:\n        f.write(content)\n        f.flush()\n        \n        from openvoicy_sidecar.model import verify_file_hash\n        assert verify_file_hash(f.name, expected_hash)\n        assert not verify_file_hash(f.name, \"wrong_hash\")\n\\`\\`\\`\n\n## AUDIO METER TESTS\n\\`\\`\\`python\n# sidecar/tests/test_meter.py\nimport numpy as np\nfrom openvoicy_sidecar.meter import calculate_levels\n\ndef test_silence_levels():\n    silence = np.zeros(1000, dtype=np.float32)\n    rms, peak = calculate_levels(silence)\n    assert rms == 0.0\n    assert peak == 0.0\n\ndef test_full_scale_levels():\n    full_scale = np.ones(1000, dtype=np.float32)\n    rms, peak = calculate_levels(full_scale)\n    assert rms == 1.0\n    assert peak == 1.0\n\ndef test_normalized_output():\n    audio = np.random.randn(1000).astype(np.float32) * 0.5\n    rms, peak = calculate_levels(audio)\n    assert 0 <= rms <= 1\n    assert 0 <= peak <= 1\n\\`\\`\\`\n\n## MOCKING STRATEGY\n- Mock audio devices using unittest.mock\n- Mock filesystem for cache tests\n- Mock network (aiohttp) for download tests\n- No real hardware dependencies in tests\n\n## CI INTEGRATION\n\\`\\`\\`yaml\n# .github/workflows/test.yml\n- name: Run Python tests\n  run: |\n    cd sidecar\n    pip install -e \".[test]\"\n    pytest -v --cov=openvoicy_sidecar\n\\`\\`\\`\n\n## TEST REQUIREMENTS\n- All tests pass on Windows, macOS, Linux\n- No tests depend on real audio hardware\n- Tests complete in < 60 seconds\n- Code coverage > 70%\n\n## WHY THIS MATTERS\nUnit tests ensure sidecar components work correctly in isolation. Shared test vectors guarantee consistency with UI preview.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:18:51.303427662Z","created_by":"ubuntu","updated_at":"2026-02-04T03:31:44.573295805Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-13v.9","depends_on_id":"translatorvoiceinputtool-13v","type":"parent-child","created_at":"2026-02-04T03:18:51.303427662Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.9","depends_on_id":"translatorvoiceinputtool-13v.4","type":"blocks","created_at":"2026-02-04T03:31:44.466874432Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.9","depends_on_id":"translatorvoiceinputtool-13v.5","type":"blocks","created_at":"2026-02-04T03:31:44.573222838Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-13v.9","depends_on_id":"translatorvoiceinputtool-13v.7","type":"blocks","created_at":"2026-02-04T03:20:37.258407492Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1ao","title":"M0: Project + Contract Lock","description":"MILESTONE M0 (Day 0-1): Foundation milestone that unblocks all parallel work.\n\n## PURPOSE\nEstablish stable file layout, lock the IPC contract, create scaffolds, and validate critical feasibility spikes BEFORE any implementation work begins. This is the coordination gate that prevents wasted effort.\n\n## KEY DELIVERABLES\n- Tauri 2 + React/Vite/Tailwind scaffold with working dev environment\n- Locked IPC Protocol v1 (shared/ipc/IPC_PROTOCOL_V1.md) with validated examples\n- Sidecar skeleton responding to ping/info\n- Platform capability spike results (hotkey hold/release, injection feasibility per OS)\n- Model manifest with pinned sources, hashes, and license verification\n- Sidecar packaging feasibility confirmation\n\n## GATE CRITERIA\n**\"ping + info + device list + meter demo\" must be merged before M1/M2 can proceed.**\n\nVerification checklist for M0 completion:\n- [ ] `tauri dev` launches successfully with hot reload\n- [ ] IPC_PROTOCOL_V1.md is complete with all methods/notifications\n- [ ] IPC_V1_EXAMPLES.jsonl parses and validates in CI\n- [ ] Sidecar responds to system.ping and system.info\n- [ ] Platform capability spike documented for all targets\n- [ ] MODEL_MANIFEST.json created with hashes and mirrors\n- [ ] Sidecar packaging feasibility confirmed per platform\n- [ ] Shared schemas created (ReplacementRule.schema.json, AppConfig.schema.json)\n\n## BACKGROUND\nOpenVoicy is a cross-platform push-to-talk voice transcription tool using:\n- Tauri 2 (Rust) for desktop shell, hotkeys, tray, text injection\n- React/TypeScript/Tailwind for settings UI\n- Python sidecar for audio capture, ASR inference (NVIDIA Parakeet TDT 0.6B), text processing\n- JSON-RPC 2.0 over stdin/stdout for IPC\n\nProduct promise: \"offline after first model download\" - no network calls once model cache is populated.\n\n## ASSUMPTIONS & CONSTRAINTS (from plan)\n- Tauri 2 is used for the desktop shell; global shortcut + tray via Tauri plugins\n- Sidecar shipped as single executable (no system Python dependency)\n- Python dependencies pinned (exact versions) in sidecar/pyproject.toml\n- **CPU-first baseline:** MVP must work acceptably on CPU-only systems. GPU is best-effort, never required.\n- Model distribution without interactive auth (mirror if upstream requires auth)\n- No runtime dependency requiring background daemon/service installation\n- Standardize data dirs:\n  - Config: OS app config directory (OpenVoicy/config.json)\n  - Cache: OS cache directory (OpenVoicy/models/...)\n  - Logs: OS log directory (OpenVoicy/logs/...)","status":"open","priority":0,"issue_type":"epic","created_at":"2026-02-04T03:01:57.183640586Z","created_by":"ubuntu","updated_at":"2026-02-04T03:39:36.558265971Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"translatorvoiceinputtool-1ao.1","title":"M0.1: Scaffold Tauri 2 + React/Vite/Tailwind","description":"Set up the complete development environment and project structure.\n\n## ACCEPTANCE CRITERIA\n- `tauri dev` launches successfully\n- UI hot reload works (change React component, see immediate update)\n- Rust command callable from UI (test with simple echo command)\n- Platform permission stubs present:\n  - macOS: usage strings for Microphone + Accessibility in Info.plist\n  - Linux: notes for required packages\n  - Windows: notes for any required permissions\n- README includes minimal \"smoke test\" command list\n\n## IMPLEMENTATION NOTES\n- Use Tauri 2 (not Tauri 1) - significant API differences\n- Vite for build tooling (faster than webpack)\n- Tailwind CSS for styling (utility-first approach)\n- TypeScript for type safety in UI code\n\n## FILE STRUCTURE TO CREATE\n- src-tauri/Cargo.toml with Tauri 2 dependencies\n- src-tauri/tauri.conf.json with app config\n- src-tauri/src/main.rs with basic setup\n- src/ directory with React app structure\n- package.json with React/Vite/Tailwind deps\n- vite.config.ts\n- tailwind.config.js\n- postcss.config.js\n\n## WHY THIS MATTERS\nThis is the foundation all other work builds on. If dev environment is broken or slow, every other task suffers. Getting this right first enables parallel work.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-02-04T03:03:31.942060710Z","created_by":"ubuntu","updated_at":"2026-02-04T05:26:12.383575548Z","closed_at":"2026-02-04T05:26:12.383506850Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1ao.1","depends_on_id":"translatorvoiceinputtool-1ao","type":"parent-child","created_at":"2026-02-04T03:03:31.942060710Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1ao.10","title":"Coordination gates and parallel execution strategy","description":"Document and track the hard coordination gates for parallel agent execution.\n\n## PURPOSE\nDefine clear synchronization points that must be reached before dependent work can proceed. This enables safe parallel development by multiple agents/developers.\n\n## RECOMMENDED 4-AGENT SPLIT (from PLAN.md)\n- **Agent A** (Rust IPC/sidecar/state/model/watchdog): M2.1-M2.4 + M2.8 + M2.10\n- **Agent B** (Rust hotkey/tray/injection/focus/history/config): M2.5-M2.7 + M2.9\n- **Agent C** (Sidecar protocol/audio/preprocess/replacements/meter): M1.1-M1.4 + M1.7-M1.8\n- **Agent D** (ML/model cache/packaging/decision record): M1.5-M1.6 + M5.1 + docs/DECISIONS\n\n## HARD COORDINATION GATES\n\n### Gate 1: IPC Contract Locked\n**Milestone:** M0 complete\n**Artifacts:**\n- [ ] shared/ipc/IPC_PROTOCOL_V1.md complete\n- [ ] shared/ipc/examples/IPC_V1_EXAMPLES.jsonl validated\n- [ ] CI validates examples parse and match shapes\n**Enables:** M1, M2 can start in parallel\n\n### Gate 2: Ping + Info + Device List + Meter Demo\n**Milestone:** M0 coordination gate\n**Artifacts:**\n- [ ] Rust spawns sidecar\n- [ ] system.ping returns valid response\n- [ ] system.info returns capabilities\n- [ ] audio.list_devices returns device list\n- [ ] audio.meter_start emits audio level events\n- [ ] Screenshot or log showing demo working\n**Enables:** Full M1 and M2 work\n\n### Gate 3: Record Loop + Focus Guard + Stub Injection Demo\n**Milestone:** M2 coordination gate\n**Artifacts:**\n- [ ] Hotkey triggers recording\n- [ ] Recording stops on release (or toggle)\n- [ ] Focus Guard captures/validates signature\n- [ ] Injection stub places text on clipboard (real injection not required)\n- [ ] Works without UI open (tray only)\n**Enables:** M3 UI work, M4 integration\n\n### Gate 4: ASR Returns Text Demo\n**Milestone:** M1.6 complete\n**Artifacts:**\n- [ ] asr.initialize completes (with real model)\n- [ ] Recording produces audio\n- [ ] Transcription returns text\n- [ ] Log showing actual transcription output\n**Enables:** E2E integration, M4.1\n\n### Gate 5: E2E Inject Without UI Demo\n**Milestone:** M4.1 complete\n**Artifacts:**\n- [ ] Full flow: hotkey → record → transcribe → inject\n- [ ] Text appears in target application\n- [ ] Works without settings window open\n- [ ] Video or screenshot showing flow\n**Enables:** Packaging (M5), release prep\n\n## GATE VERIFICATION PROCESS\nEach gate must have:\n1. Concrete demo script (scripts/demo-gate-N.sh)\n2. Log/screenshot artifact committed to repo\n3. Sign-off comment on gate tracking issue\n4. Dependent work can only start after sign-off\n\n## DEMO SCRIPT TEMPLATE\n```bash\n#!/bin/bash\n# scripts/demo-gate-1.sh\n# Gate 1: IPC Contract Locked\n\necho \"=== Gate 1: IPC Contract Verification ===\"\n\n# Check files exist\n[ -f shared/ipc/IPC_PROTOCOL_V1.md ] || { echo \"FAIL: Protocol doc missing\"; exit 1; }\n[ -f shared/ipc/examples/IPC_V1_EXAMPLES.jsonl ] || { echo \"FAIL: Examples missing\"; exit 1; }\n\n# Validate examples parse\npython3 -c \"\nimport json\nwith open('shared/ipc/examples/IPC_V1_EXAMPLES.jsonl') as f:\n    for i, line in enumerate(f, 1):\n        try:\n            json.loads(line)\n        except:\n            print(f'FAIL: Line {i} invalid JSON')\n            exit(1)\nprint('PASS: All examples parse as valid JSON')\n\"\n\n# Validate shapes match protocol\n./scripts/validate-ipc-examples.py || { echo \"FAIL: Shape validation\"; exit 1; }\n\necho \"=== Gate 1: PASSED ===\"\n```\n\n## BLOCKING RELATIONSHIPS\n- Gate 1 blocks: All M1 and M2 tasks\n- Gate 2 blocks: M1.3+, M2.4+\n- Gate 3 blocks: M3, M4.1\n- Gate 4 blocks: M4.1, full E2E\n- Gate 5 blocks: M5, release\n\n## WHY THIS MATTERS\nClear gates prevent wasted work on incompatible implementations. Each gate is a concrete, verifiable synchronization point that ensures all parallel workstreams stay aligned.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:44:08.005394252Z","created_by":"ubuntu","updated_at":"2026-02-04T03:44:08.005394252Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1ao.10","depends_on_id":"translatorvoiceinputtool-1ao","type":"parent-child","created_at":"2026-02-04T03:44:08.005394252Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1ao.2","title":"M0.2: Lock IPC Protocol v1","description":"Create the authoritative IPC contract document with validated examples.\n\n## ACCEPTANCE CRITERIA\n- shared/ipc/IPC_PROTOCOL_V1.md exists and is complete\n- shared/ipc/examples/IPC_V1_EXAMPLES.jsonl exists with all method/notification examples\n- Examples cover:\n  - Each method with success response\n  - Common error responses with numeric JSON-RPC codes\n  - Each notification type\n  - error.data.kind values for all error categories\n- CI validates JSONL parses correctly\n- CI validates examples match stated shapes in protocol doc\n\n## PROTOCOL SUMMARY\n- Transport: NDJSON (newline-delimited JSON) over stdin/stdout\n- Framing: one JSON object per line, flush after each\n- Request: { jsonrpc:\"2.0\", id:string|number, method:string, params?:object }\n- Response: { jsonrpc:\"2.0\", id, result?:any, error?:{ code:number, message:string, data?:{ kind:string, details?:any } } }\n- Notification: { jsonrpc:\"2.0\", method:string, params:object }\n- Safety: Enforce max inbound line length (1 MiB) on both sides; oversized = fatal\n\n## METHODS TO DOCUMENT (COMPLETE LIST)\n**System methods:**\n- system.ping → { version: string, protocol: \"v1\" }\n- system.info → { version, protocol:\"v1\", capabilities, runtime }\n- system.shutdown { reason?: string } → { status:\"shutting_down\" }\n\n**Audio methods:**\n- audio.list_devices → { devices: [...] }\n- audio.set_device { device_uid: string|null } → { active_device_uid: string|null }\n- audio.meter_start { device_uid?: string|null, interval_ms?: number } → { status:\"started\" }\n  - interval_ms default 80ms, **clamp 30-250ms**\n- audio.meter_stop → { status:\"stopped\" }\n\n**Model methods:**\n- model.get_status → { model_id, revision, status, progress?, cache_path? }\n  - status: \"missing\"|\"downloading\"|\"verifying\"|\"ready\"|\"error\"\n- model.purge_cache { model_id?: string } → { purged:boolean }\n  - Reject with E_NOT_READY if model in use\n\n**ASR methods:**\n- asr.initialize { model_id: string, device_pref: \"auto\"|\"cuda\"|\"cpu\" } → { status:\"ready\", model_id:string, device:\"cuda\"|\"cpu\" }\n  - Idempotent; fast path (<250ms) when already initialized\n\n**Recording methods:**\n- recording.start { session_id:string, device_uid?:string|null } → { session_id:string }\n  - Rust generates session_id (UUID v4), passes to sidecar\n- recording.stop { session_id:string } → { audio_duration_ms:number }\n  - Must return quickly (<250ms); transcription async\n- recording.cancel { session_id:string } → { status:\"cancelled\" }\n  - Discards audio, MUST NOT emit transcription_complete\n\n**Replacement methods:**\n- replacements.set_rules { rules: ReplacementRule[] } → { count:number }\n\n**Status methods:**\n- status.get → { state:\"idle\"|\"loading_model\"|\"recording\"|\"transcribing\"|\"error\", detail?:string, model?:ModelStatus }\n\n## NOTIFICATIONS TO DOCUMENT\n- event.status_changed { state, detail?, progress?, model? }\n  - progress uses cumulative bytes for downloads when unit:\"bytes\"\n- event.audio_level { source:\"meter\"|\"recording\", session_id?:string, rms:number, peak:number }\n  - rms/peak normalized floats 0..1\n- event.transcription_complete { session_id, text, confidence?:number, duration_ms:number }\n  - text is postprocessed and replacements-applied\n  - confidence range 0-1 if present\n  - duration_ms is transcription compute time (not audio duration)\n- event.transcription_error { session_id, kind:string, message:string }\n\n## ERROR KINDS (stable strings in error.data.kind)\nE_METHOD_NOT_FOUND, E_INVALID_PARAMS, E_NOT_READY, E_MIC_PERMISSION, E_DEVICE_NOT_FOUND, E_AUDIO_IO, E_NETWORK, E_DISK_FULL, E_CACHE_CORRUPT, E_MODEL_LOAD, E_TRANSCRIBE, E_INTERNAL\n\n## JSON-RPC 2.0 ERROR CODES\n- -32700: Parse error\n- -32600: Invalid Request\n- -32601: Method not found (E_METHOD_NOT_FOUND)\n- -32602: Invalid params (E_INVALID_PARAMS)\n- -32603: Internal error (E_INTERNAL)\n- -32000 to -32099: Server error (our custom: E_NOT_READY, E_MIC_PERMISSION, etc.)\n\n## TIMEOUT POLICY (Rust defaults)\n- system.ping: 1s\n- system.info: 2s\n- audio.list_devices: 2s\n- audio.set_device: 2s\n- audio.meter_start/stop: 2s\n- model.get_status: 2s\n- model.purge_cache: 10s\n- recording.start/stop/cancel: 2s\n- replacements.set_rules: 2s\n- status.get: 2s\n- asr.initialize: 20 minutes (first-run download!)\n- Short-method timeouts: recoverable by 1 retry\n- asr.initialize timeout: fatal (error state; remediation: restart sidecar)\n\n## REPLACEMENTRULE SCHEMA (normative)\nRequired: id (UUID), enabled (bool), kind (\"literal\"|\"regex\"), pattern (non-empty), replacement, word_boundary (bool), case_sensitive (bool)\nOptional: description (string), origin (\"user\"|\"preset\")\n\n**Constraints:**\n- Max rules: 500\n- Pattern max length: 256\n- Replacement max length: 1024\n- Output max length: 50,000 chars (truncate with warning)\n\n**Semantics:**\n- Pipeline order (locked): postprocess normalization → macro expansion → replacements apply-all in order\n- Single pass, no recursion\n\n**Macros (MVP minimal set; deterministic):**\n- {{date}} → local timezone ISO date\n- {{time}} → local timezone 24h time\n- {{datetime}} → local timezone date + time\n\n## TEST REQUIREMENTS\n- Unit tests parse all example messages in IPC_V1_EXAMPLES.jsonl\n- Fuzz test JSON-RPC parser with malformed inputs\n- Validate error code ranges\n- Test timeout handling\n\n## WHY THIS MATTERS\nThis is THE integration boundary. Both Rust and Python implement to this spec. Locking it early prevents drift and enables parallel development.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-02-04T03:03:49.484926638Z","created_by":"ubuntu","updated_at":"2026-02-04T05:14:03.955075499Z","closed_at":"2026-02-04T05:14:03.955030745Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1ao.2","depends_on_id":"translatorvoiceinputtool-1ao","type":"parent-child","created_at":"2026-02-04T03:03:49.484926638Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1ao.3","title":"M0.3: Sidecar skeleton + ping/info handlers","description":"Create minimal Python sidecar that responds to basic IPC commands.\n\n## ACCEPTANCE CRITERIA\n- Rust can spawn sidecar executable\n- Rust calls system.ping and receives valid response\n- Rust calls system.info and receives valid response\n- stdout is strict NDJSON (no other output)\n- All logs go to stderr only\n- Sidecar exits cleanly on EOF\n\n## SIDECAR STRUCTURE\n- sidecar/pyproject.toml with pinned dependencies\n- sidecar/src/openvoicy_sidecar/__main__.py (entry point)\n- sidecar/src/openvoicy_sidecar/server.py (JSON-RPC loop)\n- sidecar/src/openvoicy_sidecar/protocol.py (message parsing)\n\n## SYSTEM.PING RESPONSE\n{ \"version\": \"0.1.0\", \"protocol\": \"v1\" }\n\n## SYSTEM.INFO RESPONSE\n{\n  \"version\": \"0.1.0\",\n  \"protocol\": \"v1\",\n  \"capabilities\": {\n    \"cuda_available\": false,\n    \"supports_progress\": true,\n    \"supports_model_purge\": true,\n    \"supports_silence_trim\": true,\n    \"supports_audio_meter\": true\n  },\n  \"runtime\": {\n    \"python\": \"3.11.x\",\n    \"platform\": \"linux\"\n  }\n}\n\n## IMPLEMENTATION NOTES\n- Use stdin/stdout for IPC, stderr for logging\n- Flush stdout after each line\n- Handle EOF gracefully (stdin closed = shutdown)\n- JSON-RPC 2.0 compliant responses\n\n## WHY THIS MATTERS\nThis proves the IPC mechanism works before adding complexity. It is the foundation for all sidecar functionality.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-02-04T03:04:01.743874721Z","created_by":"ubuntu","updated_at":"2026-02-04T05:28:24.349685005Z","closed_at":"2026-02-04T05:28:24.349651973Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1ao.3","depends_on_id":"translatorvoiceinputtool-1ao","type":"parent-child","created_at":"2026-02-04T03:04:01.743874721Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1ao.3","depends_on_id":"translatorvoiceinputtool-1ao.2","type":"blocks","created_at":"2026-02-04T03:19:23.984798520Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1ao.4","title":"M0.4: Platform capability verification spike","description":"Document hotkey hold/release + injection behavior for each target platform.\n\n## ACCEPTANCE CRITERIA\n- Document behavior for Windows, macOS, X11, and Wayland:\n  - Global shortcut press/release event reliability\n  - Paste keystroke injection feasibility\n  - Required permissions and how to detect them\n- Wayland: document portal GlobalShortcuts availability/behavior\n- Define per-platform default effective modes\n- Draft Diagnostics wording for each platform\n\n## INVESTIGATION AREAS\n\n### Windows\n- Global hotkey via RegisterHotKey API\n- Key-down/key-up reliability\n- Clipboard + SendInput for paste injection\n- No special permissions typically needed\n\n### macOS\n- Global hotkey via CGEventTap or Accessibility APIs\n- Accessibility permission required for global hotkeys\n- Microphone permission required for audio\n- Clipboard + AppleScript or CGEvent for paste\n\n### Linux X11\n- Global hotkey via X11 grabs\n- Generally reliable press/release\n- xdotool or xclip for injection\n- No special permissions typically\n\n### Linux Wayland\n- XDG Desktop Portal GlobalShortcuts interface\n- Typically toggle-only (no reliable key-up)\n- Clipboard-only injection (no keystroke synthesis allowed)\n- May need portal request for shortcuts\n\n## OUTPUT DELIVERABLES\n- docs/KNOWN_LIMITATIONS.md draft with platform sections\n- capabilities.rs design notes\n- Remediation text draft for each permission/constraint scenario\n\n## WHY THIS MATTERS\nWe cannot design the capability detection system without knowing what each platform can and cannot do. This spike prevents building features that wont work.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-02-04T03:04:17.989577323Z","created_by":"ubuntu","updated_at":"2026-02-04T05:30:05.563695304Z","closed_at":"2026-02-04T05:30:05.563646293Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1ao.4","depends_on_id":"translatorvoiceinputtool-1ao","type":"parent-child","created_at":"2026-02-04T03:04:17.989577323Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1ao.5","title":"M0.5: Model source/revision + manifest + license verification","description":"Create pinned model manifest and verify redistribution rights.\n\n## ACCEPTANCE CRITERIA\n- shared/model/MODEL_MANIFEST.json exists with:\n  - Human-readable source identifier\n  - Immutable revision identifier\n  - SHA-256 hashes for all files\n  - Expected uncompressed sizes\n  - File list with relative paths\n  - Schema version\n  - Mirror URLs for redundancy\n- Redistribution terms confirmed and documented\n- docs/THIRD_PARTY_NOTICES.md includes model license and attribution\n- docs/DECISIONS/0001-asr-backend.md created with backend decision record\n- CI validates manifest parses correctly\n- CI validates asr.initialize model_id values match manifest entries\n\n## MODEL INFORMATION\nPrimary target: NVIDIA Parakeet TDT 0.6B v3\n- Check HuggingFace/NVIDIA source for latest revision\n- Verify license permits redistribution\n- Confirm no authentication required for download (or mirror if needed)\n\n## MANIFEST SCHEMA\n{\n  \"schema_version\": \"1\",\n  \"model_id\": \"parakeet-tdt-0.6b-v3\",\n  \"source\": \"nvidia/parakeet-tdt-0.6b\",\n  \"revision\": \"abc123...\",\n  \"license\": \"...\",\n  \"files\": [\n    {\n      \"path\": \"model.onnx\",\n      \"size_bytes\": 123456789,\n      \"sha256\": \"...\"\n    }\n  ],\n  \"mirrors\": [\n    \"https://mirror1.example.com/...\",\n    \"https://mirror2.example.com/...\"\n  ],\n  \"total_size_bytes\": 987654321\n}\n\n## WHY THIS MATTERS\nModel distribution is a legal and technical risk. We must verify redistribution rights before building download infrastructure. Pinning ensures reproducibility.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-02-04T03:04:32.900883561Z","created_by":"ubuntu","updated_at":"2026-02-04T05:17:33.668018703Z","closed_at":"2026-02-04T05:17:33.667915620Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1ao.5","depends_on_id":"translatorvoiceinputtool-1ao","type":"parent-child","created_at":"2026-02-04T03:04:32.900883561Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1ao.6","title":"M0.6: Sidecar packaging feasibility spike","description":"Verify we can package the sidecar with audio + ML dependencies as a standalone binary.\n\n## ACCEPTANCE CRITERIA\n- Build minimal sidecar binary that runs:\n  - system.ping\n  - audio.list_devices\n  - audio.meter_start (with real audio capture)\n- Capture and document:\n  - Binary size for each platform\n  - Startup time to first ping response\n  - Native dependency requirements\n- File HARD GO/NO-GO decision for primary ASR packaging per OS/arch\n- Document contingency: fallback backend stays behind same IPC contract\n\n## PLATFORMS TO TEST\n- Windows x64\n- macOS x64 (Intel)\n- macOS arm64 (Apple Silicon)\n- Linux x64\n\n## DEPENDENCIES TO PACKAGE\n- Python runtime (embedded via PyInstaller)\n- Audio libraries (sounddevice, PortAudio)\n- ML dependencies (PyTorch or ONNX Runtime, depending on backend)\n- NumPy, etc.\n\n## EXPECTED CHALLENGES\n- Binary size (PyTorch is large)\n- Native library linking (PortAudio, CUDA)\n- Startup time (Python + ML framework initialization)\n- Platform-specific audio API differences\n\n## DECISION CRITERIA\n- Binary size < 500MB acceptable for MVP\n- Startup time < 5s acceptable for MVP\n- Must work on CPU-only systems\n- GPU is nice-to-have, not required\n\n## CONTINGENCY PLAN\nIf primary backend proves impractical to package:\n- Fallback to smaller model (Whisper tiny, etc.)\n- Use ONNX runtime instead of PyTorch\n- Backend swap is invisible to Rust/UI (same IPC contract)\n\n## WHY THIS MATTERS\nIf we cannot package the sidecar, the entire architecture fails. This spike must complete before significant M1 work.","status":"open","priority":0,"issue_type":"task","created_at":"2026-02-04T03:04:53.334917703Z","created_by":"ubuntu","updated_at":"2026-02-04T03:04:53.334917703Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1ao.6","depends_on_id":"translatorvoiceinputtool-1ao","type":"parent-child","created_at":"2026-02-04T03:04:53.334917703Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1ao.7","title":"Create shared schema files","description":"Create JSON Schema files for ReplacementRule and AppConfig - the single source of truth for type validation.\n\n## ACCEPTANCE CRITERIA\n- shared/schema/ReplacementRule.schema.json created and complete\n- shared/schema/AppConfig.schema.json created and complete\n- Schemas are JSON Schema draft-07 compliant\n- CI validates all implementations match these schemas\n- Schema drift checks fail build if types diverge\n\n## FILES TO CREATE\n- shared/schema/ReplacementRule.schema.json\n- shared/schema/AppConfig.schema.json\n\n## REPLACEMENTRULE SCHEMA\n\\`\\`\\`json\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"required\": [\"id\", \"enabled\", \"kind\", \"pattern\", \"replacement\", \"word_boundary\", \"case_sensitive\"],\n  \"properties\": {\n    \"id\": { \"type\": \"string\", \"format\": \"uuid\" },\n    \"enabled\": { \"type\": \"boolean\" },\n    \"kind\": { \"enum\": [\"literal\", \"regex\"] },\n    \"pattern\": { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 256 },\n    \"replacement\": { \"type\": \"string\", \"maxLength\": 1024 },\n    \"word_boundary\": { \"type\": \"boolean\" },\n    \"case_sensitive\": { \"type\": \"boolean\" },\n    \"description\": { \"type\": \"string\" },\n    \"origin\": { \"enum\": [\"user\", \"preset\"] }\n  }\n}\n\\`\\`\\`\n\n## APPCONFIG SCHEMA\nTop-level sections:\n- schema_version: integer (current: 1)\n- audio: { device_uid, audio_cues_enabled }\n- hotkeys: { primary, copy_last, mode }\n- injection: { paste_delay_ms, restore_clipboard, suffix, focus_guard_enabled }\n- replacements: array of ReplacementRule\n- ui: { window_size, theme, show_on_startup }\n\n## VALIDATION USAGE\n- Python: jsonschema library validates at runtime\n- TypeScript: generate types from schema or validate at compile time\n- Rust: serde with custom validation\n\n## CI DRIFT DETECTION\nCompare generated types across languages:\n1. Rust: Extract serde struct definitions\n2. TypeScript: Extract interface definitions  \n3. Python: Extract dataclass/TypedDict definitions\n4. Fail if any type diverges from JSON Schema\n\n## TEST REQUIREMENTS\n- Unit test schema parses correctly\n- Test validation against known-good configs\n- Test validation rejects invalid configs\n- CI job validates schema consistency\n\n## WHY THIS MATTERS\nThese schemas are the single source of truth preventing type drift between Rust, TypeScript, and Python. Without this, subtle bugs will appear when types diverge.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:17:50.880754293Z","created_by":"ubuntu","updated_at":"2026-02-04T03:27:20.044238239Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1ao.7","depends_on_id":"translatorvoiceinputtool-1ao","type":"parent-child","created_at":"2026-02-04T03:17:50.880754293Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1ao.8","title":"Create replacement test vectors","description":"Create shared test vectors for replacement rule validation and preset rule sets.\n\n## ACCEPTANCE CRITERIA\n- shared/replacements/TEST_VECTORS.json exists with comprehensive test cases\n- shared/replacements/PRESETS.json exists with preset rule categories\n- Both Python and UI tests consume these vectors\n- Tests verify identical output across implementations\n- Macros ({{date}}, {{time}}, {{datetime}}) covered by test vectors\n\n## FILES TO CREATE\n- shared/replacements/TEST_VECTORS.json\n- shared/replacements/PRESETS.json\n\n## TEST_VECTORS.json FORMAT\n\\`\\`\\`json\n{\n  \"version\": 1,\n  \"test_cases\": [\n    {\n      \"name\": \"literal_word_boundary\",\n      \"input\": \"Hello brb world\",\n      \"rules\": [\n        {\n          \"id\": \"test-1\",\n          \"enabled\": true,\n          \"kind\": \"literal\",\n          \"pattern\": \"brb\",\n          \"replacement\": \"be right back\",\n          \"word_boundary\": true,\n          \"case_sensitive\": false\n        }\n      ],\n      \"expected\": \"Hello be right back world\"\n    },\n    {\n      \"name\": \"regex_pattern\",\n      \"input\": \"I saw teh cat\",\n      \"rules\": [\n        {\n          \"id\": \"test-2\",\n          \"enabled\": true,\n          \"kind\": \"regex\",\n          \"pattern\": \"\\\\\\\\bteh\\\\\\\\b\",\n          \"replacement\": \"the\",\n          \"word_boundary\": false,\n          \"case_sensitive\": false\n        }\n      ],\n      \"expected\": \"I saw the cat\"\n    },\n    {\n      \"name\": \"macro_date\",\n      \"input\": \"Today is {{date}}\",\n      \"rules\": [],\n      \"expected_pattern\": \"Today is \\\\\\\\d{4}-\\\\\\\\d{2}-\\\\\\\\d{2}\"\n    },\n    {\n      \"name\": \"macro_time\",\n      \"input\": \"The time is {{time}}\",\n      \"rules\": [],\n      \"expected_pattern\": \"The time is \\\\\\\\d{2}:\\\\\\\\d{2}\"\n    },\n    {\n      \"name\": \"macro_datetime\",\n      \"input\": \"Now: {{datetime}}\",\n      \"rules\": [],\n      \"expected_pattern\": \"Now: \\\\\\\\d{4}-\\\\\\\\d{2}-\\\\\\\\d{2} \\\\\\\\d{2}:\\\\\\\\d{2}\"\n    },\n    {\n      \"name\": \"multiple_rules_order\",\n      \"input\": \"brb omw btw\",\n      \"rules\": [\n        {\"id\": \"r1\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"brb\", \"replacement\": \"be right back\", \"word_boundary\": true, \"case_sensitive\": false},\n        {\"id\": \"r2\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"omw\", \"replacement\": \"on my way\", \"word_boundary\": true, \"case_sensitive\": false},\n        {\"id\": \"r3\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"btw\", \"replacement\": \"by the way\", \"word_boundary\": true, \"case_sensitive\": false}\n      ],\n      \"expected\": \"be right back on my way by the way\"\n    },\n    {\n      \"name\": \"disabled_rule_skipped\",\n      \"input\": \"Hello brb\",\n      \"rules\": [\n        {\"id\": \"r1\", \"enabled\": false, \"kind\": \"literal\", \"pattern\": \"brb\", \"replacement\": \"be right back\", \"word_boundary\": true, \"case_sensitive\": false}\n      ],\n      \"expected\": \"Hello brb\"\n    },\n    {\n      \"name\": \"case_sensitive_match\",\n      \"input\": \"Hello BRB brb\",\n      \"rules\": [\n        {\"id\": \"r1\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"brb\", \"replacement\": \"be right back\", \"word_boundary\": true, \"case_sensitive\": true}\n      ],\n      \"expected\": \"Hello BRB be right back\"\n    },\n    {\n      \"name\": \"no_recursion\",\n      \"input\": \"a\",\n      \"rules\": [\n        {\"id\": \"r1\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"a\", \"replacement\": \"aa\", \"word_boundary\": false, \"case_sensitive\": false}\n      ],\n      \"expected\": \"aa\",\n      \"note\": \"Single pass, no recursion - 'aa' is not processed again\"\n    }\n  ]\n}\n\\`\\`\\`\n\n## PRESETS.json FORMAT\n\\`\\`\\`json\n{\n  \"version\": 1,\n  \"presets\": {\n    \"common_abbreviations\": {\n      \"name\": \"Common Abbreviations\",\n      \"description\": \"Expand common chat abbreviations\",\n      \"rules\": [\n        {\"id\": \"preset-brb\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"brb\", \"replacement\": \"be right back\", \"word_boundary\": true, \"case_sensitive\": false, \"origin\": \"preset\"},\n        {\"id\": \"preset-btw\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"btw\", \"replacement\": \"by the way\", \"word_boundary\": true, \"case_sensitive\": false, \"origin\": \"preset\"},\n        {\"id\": \"preset-omw\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"omw\", \"replacement\": \"on my way\", \"word_boundary\": true, \"case_sensitive\": false, \"origin\": \"preset\"}\n      ]\n    },\n    \"punctuation\": {\n      \"name\": \"Spoken Punctuation\",\n      \"description\": \"Convert spoken punctuation words\",\n      \"rules\": [\n        {\"id\": \"preset-period\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"period\", \"replacement\": \".\", \"word_boundary\": true, \"case_sensitive\": false, \"origin\": \"preset\"},\n        {\"id\": \"preset-comma\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"comma\", \"replacement\": \",\", \"word_boundary\": true, \"case_sensitive\": false, \"origin\": \"preset\"},\n        {\"id\": \"preset-question\", \"enabled\": true, \"kind\": \"literal\", \"pattern\": \"question mark\", \"replacement\": \"?\", \"word_boundary\": true, \"case_sensitive\": false, \"origin\": \"preset\"}\n      ]\n    }\n  }\n}\n\\`\\`\\`\n\n## TEST REQUIREMENTS\n- Python tests load TEST_VECTORS.json and verify sidecar output\n- TypeScript tests load TEST_VECTORS.json and verify UI preview\n- Both must produce identical results\n- CI fails if outputs diverge\n- Edge case tests: empty input, max length, special characters\n\n## WHY THIS MATTERS\nShared test vectors prevent drift between sidecar (where replacements execute) and UI (where preview is shown). Users expect preview to match actual output.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:18:01.131781118Z","created_by":"ubuntu","updated_at":"2026-02-04T03:27:43.448549156Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1ao.8","depends_on_id":"translatorvoiceinputtool-1ao","type":"parent-child","created_at":"2026-02-04T03:18:01.131781118Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1ao.9","title":"ASR backend decision record","description":"Create docs/DECISIONS/0001-asr-backend.md documenting the ASR backend choice.\n\n## ACCEPTANCE CRITERIA\n- docs/DECISIONS/0001-asr-backend.md created\n- Documents primary backend choice and rationale\n- Documents fallback backend strategy\n- License implications documented\n- Performance characteristics documented\n- Decision process recorded\n\n## DECISION RECORD FORMAT (ADR)\n\\`\\`\\`markdown\n# ADR 0001: ASR Backend Selection\n\n## Status\nAccepted\n\n## Context\nOpenVoicy needs a speech-to-text backend that:\n- Works offline after initial model download\n- Runs on CPU (GPU optional)\n- Has acceptable accuracy for dictation\n- Can be packaged without complex dependencies\n- Has redistributable license\n\n## Options Considered\n\n### 1. NVIDIA Parakeet TDT 0.6B v3\n- Pros: High accuracy, relatively small, fast on CPU\n- Cons: NVIDIA proprietary license (verify redistribution)\n- Size: ~600MB\n- Latency: ~1-2s for typical utterances on CPU\n\n### 2. OpenAI Whisper (via whisper.cpp or faster-whisper)\n- Pros: Open source (MIT), well-documented\n- Cons: Larger models for comparable accuracy\n- Size: tiny=75MB, base=140MB, small=460MB\n- Latency: varies by model size\n\n### 3. Mozilla DeepSpeech\n- Pros: Fully open source\n- Cons: Lower accuracy, deprecated\n- Size: ~180MB\n- Latency: slower than alternatives\n\n### 4. Vosk\n- Pros: Lightweight, many language models\n- Cons: Lower accuracy than Whisper/Parakeet\n- Size: varies by model\n\n## Decision\nPrimary: NVIDIA Parakeet TDT 0.6B v3\n- Best accuracy-to-size ratio\n- Fast on CPU\n- License verified for redistribution via [source]\n\nFallback: Whisper small (if Parakeet licensing becomes problematic)\n- Open source\n- Acceptable accuracy\n- Well-supported ecosystem\n\n## Consequences\n- Must verify Parakeet redistribution rights before M0.5 completion\n- Sidecar architecture abstracts backend (easy to swap)\n- CPU-only baseline required; CUDA is optional optimization\n- Model download size ~600MB affects first-run experience\n\n## Related\n- M0.5: Model manifest and license verification\n- M1.6: ASR backend implementation\n\\`\\`\\`\n\n## DIRECTORY STRUCTURE\n\\`\\`\\`\ndocs/\n  DECISIONS/\n    0001-asr-backend.md\n    README.md (index of decisions)\n\\`\\`\\`\n\n## TEST REQUIREMENTS\n- N/A (documentation task)\n\n## WHY THIS MATTERS\nDecision records document why choices were made, preventing future confusion and enabling informed changes. If we need to switch backends, this document explains the original rationale.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:29:18.583408207Z","created_by":"ubuntu","updated_at":"2026-02-04T03:29:22.626121810Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1ao.9","depends_on_id":"translatorvoiceinputtool-1ao","type":"parent-child","created_at":"2026-02-04T03:29:18.583408207Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1ao.9","depends_on_id":"translatorvoiceinputtool-1ao.5","type":"blocks","created_at":"2026-02-04T03:29:22.626048664Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1xu","title":"M3: UI MVP","description":"MILESTONE M3 (Day 2-4): Configure without CLI; status visibility; model and history UX; setup confidence.\n\n## PURPOSE\nBuild the React-based settings UI that allows users to configure all aspects of OpenVoicy without needing CLI access. Provides visual feedback for status, history, and diagnostics.\n\n## KEY DELIVERABLES\n- Status indicator + transcript history view\n- Settings panels: mic, hotkey, injection, replacements, audio cues\n- Microphone test + level meter\n- Model settings: status/progress, download now, purge cache\n- Replacements manager: CRUD, presets, import/export, preview\n- Diagnostics + Self-check panel\n\n## ARCHITECTURE CONTEXT\nUI communicates with Rust via Tauri commands. Settings apply live; rollback on failure. All state is owned by Rust; UI is a view/controller.\n\n## UX PRIORITIES\n- First-run experience: user should feel confident the app is working before first transcription\n- Mic test + level meter provides immediate feedback that audio is capturing\n- Model download progress visible and interruptible\n- Error states provide actionable remediation steps\n\n## DEPENDENCIES\n- Requires M2 Rust commands to be exposed for UI to call\n- Replacements preview should mirror sidecar semantics (shared test vectors)","status":"open","priority":1,"issue_type":"epic","created_at":"2026-02-04T03:02:47.265862547Z","created_by":"ubuntu","updated_at":"2026-02-04T03:02:47.265862547Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"translatorvoiceinputtool-1xu.1","title":"M3.1: Status + transcript history view","description":"Implement the main status display and transcript history in the UI.\n\n## ACCEPTANCE CRITERIA\n- Shows current app state (idle, recording, transcribing, error)\n- Shows recent transcripts with copy actions\n- Indicates injected vs clipboard-only for each transcript\n- Shows reason if clipboard-only (focus changed, permission, etc.)\n- Newest transcripts appear first\n- Copy action works for individual transcripts\n\n## IMPLEMENTATION NOTES\nFiles:\n- src/components/StatusIndicator.tsx\n- src/components/Settings/HistoryPanel.tsx\n\n## STATUS INDICATOR STATES\n```typescript\ntype AppState = \"idle\" | \"loading_model\" | \"recording\" | \"transcribing\" | \"error\";\n\ninterface StatusIndicatorProps {\n    state: AppState;\n    detail?: string;\n    progress?: { current: number; total: number };\n}\n```\n\nVisual states:\n- Idle: green dot, \"Ready\"\n- Recording: red pulsing dot, \"Recording...\"\n- Transcribing: yellow spinner, \"Transcribing...\"\n- LoadingModel: blue spinner + progress bar\n- Error: red exclamation, error message\n\n## TRANSCRIPT HISTORY COMPONENT\n```typescript\ninterface TranscriptEntry {\n    id: string;\n    text: string;\n    timestamp: string;\n    audioDurationMs: number;\n    injectionResult: \n        | { type: \"injected\" }\n        | { type: \"clipboardOnly\"; reason: string }\n        | { type: \"error\"; message: string };\n}\n\nfunction HistoryPanel({ entries }: { entries: TranscriptEntry[] }) {\n    return (\n        <div className=\"space-y-2\">\n            {entries.map(entry => (\n                <TranscriptCard key={entry.id} entry={entry} />\n            ))}\n        </div>\n    );\n}\n```\n\n## TRANSCRIPT CARD\n- Text preview (truncated with ellipsis)\n- Timestamp (\"2 minutes ago\")\n- Duration (\"3.5s of audio\")\n- Badge: ✅ Injected | 📋 Clipboard | ⚠️ Error\n- Reason tooltip if clipboard-only\n- Copy button\n\n## EMPTY STATE\n\"No recent transcripts. Press the hotkey to start recording.\"\n\n## WHY THIS MATTERS\nThe history view lets users review and access recent transcriptions without re-recording.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:11:08.761762762Z","created_by":"ubuntu","updated_at":"2026-02-04T04:46:18.368452189Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1xu.1","depends_on_id":"translatorvoiceinputtool-1xu","type":"parent-child","created_at":"2026-02-04T03:11:08.761762762Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.1","depends_on_id":"translatorvoiceinputtool-t89.15","type":"blocks","created_at":"2026-02-04T04:46:18.368323570Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.1","depends_on_id":"translatorvoiceinputtool-t89.6","type":"blocks","created_at":"2026-02-04T03:20:04.998098619Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1xu.2","title":"M3.2: Settings panels (mic, hotkey, injection, cues)","description":"Implement the main settings UI for configuration options.\n\n## ACCEPTANCE CRITERIA\n- Settings apply live (no Save button needed)\n- Rollback on failure (revert to previous value)\n- Microphone dropdown populated from device list\n- Hotkey configuration with hold/toggle mode\n- Shows effective mode with reason\n- Injection settings (delay, restore clipboard, suffix, Focus Guard)\n- Audio cues toggle\n\n## IMPLEMENTATION NOTES\nFiles:\n- src/components/Settings/SettingsPanel.tsx\n- src/components/Settings/MicrophoneSelect.tsx\n- src/components/Settings/HotkeyConfig.tsx\n- src/components/Settings/InjectionSettings.tsx\n\n## MICROPHONE SELECT\n```typescript\nfunction MicrophoneSelect() {\n    const [devices, setDevices] = useState<AudioDevice[]>([]);\n    const [selected, setSelected] = useState<string | null>(null);\n    \n    useEffect(() => {\n        invoke(\"get_audio_devices\").then(setDevices);\n    }, []);\n    \n    const handleChange = async (uid: string) => {\n        try {\n            await invoke(\"set_audio_device\", { deviceUid: uid });\n            setSelected(uid);\n        } catch (e) {\n            // Rollback: keep previous selection\n            showError(\"Failed to select device\");\n        }\n    };\n}\n```\n\n## HOTKEY CONFIG\n- Primary hotkey input with recorder\n- \"Copy last\" hotkey input\n- Hold vs Toggle mode selector\n- \"Effective mode\" display with reason if different\n\n## INJECTION SETTINGS\n- Paste delay slider (10-500ms)\n- Restore clipboard checkbox\n- Suffix selector: None | Space | Newline\n- Focus Guard checkbox\n- Explanation tooltips for each setting\n\n## AUDIO CUES\n- Enable/disable toggle\n- Optional: volume slider (or follow system)\n\n## LIVE APPLY PATTERN\n```typescript\nconst handleSettingChange = async (key: string, value: any) => {\n    const previous = settings[key];\n    setSettings(prev => ({ ...prev, [key]: value }));\n    \n    try {\n        await invoke(\"update_setting\", { key, value });\n    } catch (e) {\n        setSettings(prev => ({ ...prev, [key]: previous }));\n        showError(`Failed to update ${key}`);\n    }\n};\n```\n\n## WHY THIS MATTERS\nSettings are the primary way users customize the app. Live apply provides immediate feedback.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:11:25.154232121Z","created_by":"ubuntu","updated_at":"2026-02-04T04:46:22.796250141Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1xu.2","depends_on_id":"translatorvoiceinputtool-1xu","type":"parent-child","created_at":"2026-02-04T03:11:25.154232121Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.2","depends_on_id":"translatorvoiceinputtool-t89.15","type":"blocks","created_at":"2026-02-04T04:46:22.796176033Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.2","depends_on_id":"translatorvoiceinputtool-t89.9","type":"blocks","created_at":"2026-02-04T03:20:05.102238372Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1xu.3","title":"M3.3: Mic test + level meter","description":"Implement real-time microphone input level display for setup verification.\n\n## ACCEPTANCE CRITERIA\n- Starts/stops meter via audio.meter_start/stop\n- Reacts to device changes (restart meter on new device)\n- Shows obvious \"no signal\" state (flat line, warning message)\n- Level meter animates smoothly (not jumpy)\n- Works without ASR model loaded\n\n## IMPLEMENTATION NOTES\nFile: src/components/Settings/MicrophoneTest.tsx\n\n## LEVEL METER COMPONENT\n```typescript\nfunction MicrophoneTest({ deviceUid }: { deviceUid: string | null }) {\n    const [level, setLevel] = useState({ rms: 0, peak: 0 });\n    const [running, setRunning] = useState(false);\n    \n    const startMeter = async () => {\n        await invoke(\"start_audio_meter\", { deviceUid, intervalMs: 80 });\n        setRunning(true);\n    };\n    \n    const stopMeter = async () => {\n        await invoke(\"stop_audio_meter\");\n        setRunning(false);\n    };\n    \n    useEffect(() => {\n        const unlisten = listen(\"audio_level\", (event) => {\n            setLevel(event.payload);\n        });\n        return () => { unlisten.then(fn => fn()); stopMeter(); };\n    }, []);\n}\n```\n\n## VISUAL REPRESENTATION\n- Horizontal bar graph (like audio mixer)\n- RMS as filled bar (green → yellow → red as level increases)\n- Peak as line indicator\n- Optional: peak hold (sticky for 1s)\n\n## LEVEL THRESHOLDS\n- Green: < 0.5 (normal speech)\n- Yellow: 0.5-0.8 (loud)\n- Red: > 0.8 (clipping/too loud)\n\n## NO SIGNAL DETECTION\n```typescript\nconst [noSignal, setNoSignal] = useState(false);\nconst [lastActivity, setLastActivity] = useState(Date.now());\n\nuseEffect(() => {\n    if (level.peak > 0.01) {\n        setLastActivity(Date.now());\n        setNoSignal(false);\n    } else if (Date.now() - lastActivity > 3000) {\n        setNoSignal(true);\n    }\n}, [level]);\n```\n\nDisplay when no signal:\n\"No audio detected. Check your microphone connection and permissions.\"\n\n## DEVICE CHANGE HANDLING\n```typescript\nuseEffect(() => {\n    if (running) {\n        stopMeter().then(() => startMeter());\n    }\n}, [deviceUid]);\n```\n\n## SMOOTH ANIMATION\n- Use requestAnimationFrame or CSS transitions\n- Decay: level smoothly drops to 0 (not instant)\n- Attack: level rises quickly (responsive)\n\n## WHY THIS MATTERS\nThe mic test gives users confidence their setup is working before first transcription. Catching permission issues early prevents frustration.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:11:43.833974364Z","created_by":"ubuntu","updated_at":"2026-02-04T04:40:13.491776284Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1xu.3","depends_on_id":"translatorvoiceinputtool-13v.2","type":"blocks","created_at":"2026-02-04T04:40:13.491679874Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.3","depends_on_id":"translatorvoiceinputtool-1xu","type":"parent-child","created_at":"2026-02-04T03:11:43.833974364Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.3","depends_on_id":"translatorvoiceinputtool-t89.2","type":"blocks","created_at":"2026-02-04T03:20:05.203605171Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1xu.4","title":"M3.4: Model settings UI","description":"Implement model status display and management actions.\n\n## ACCEPTANCE CRITERIA\n- Exposes model.get_status to UI\n- Shows download progress with visual progress bar\n- \"Download now\" button for proactive download\n- \"Purge cache\" button for re-download\n- Status states: missing, downloading, verifying, ready, error\n- Error state shows message and retry action\n\n## IMPLEMENTATION NOTES\nFile: src/components/Settings/ModelSettings.tsx\n\n## MODEL STATUS DISPLAY\n```typescript\ninterface ModelStatus {\n    modelId: string;\n    revision: string;\n    status: \"missing\" | \"downloading\" | \"verifying\" | \"ready\" | \"error\";\n    progress?: { current: number; total: number; unit: string };\n    cachePath?: string;\n    errorMessage?: string;\n}\n\nfunction ModelSettings() {\n    const [status, setStatus] = useState<ModelStatus | null>(null);\n    \n    useEffect(() => {\n        invoke<ModelStatus>(\"get_model_status\").then(setStatus);\n        \n        const unlisten = listen(\"model_status_changed\", (event) => {\n            setStatus(event.payload);\n        });\n        return () => { unlisten.then(fn => fn()); };\n    }, []);\n}\n```\n\n## STATUS RENDERING\n```typescript\nfunction renderStatus(status: ModelStatus) {\n    switch (status.status) {\n        case \"missing\":\n            return (\n                <Alert variant=\"warning\">\n                    Model not downloaded. Click \"Download\" to get started.\n                </Alert>\n            );\n        case \"downloading\":\n            return (\n                <Progress \n                    value={status.progress.current} \n                    max={status.progress.total}\n                    label={formatBytes(status.progress.current) + \" / \" + formatBytes(status.progress.total)}\n                />\n            );\n        case \"verifying\":\n            return <Spinner label=\"Verifying model integrity...\" />;\n        case \"ready\":\n            return (\n                <Success>\n                    Model ready ({status.modelId} @ {status.revision.slice(0, 8)})\n                </Success>\n            );\n        case \"error\":\n            return (\n                <Alert variant=\"error\">\n                    {status.errorMessage}\n                    <Button onClick={retryDownload}>Retry</Button>\n                </Alert>\n            );\n    }\n}\n```\n\n## ACTIONS\n```typescript\nconst downloadModel = async () => {\n    await invoke(\"download_model\");\n    // Status updates via events\n};\n\nconst purgeCache = async () => {\n    if (!confirm(\"This will delete the cached model. You will need to download it again.\")) {\n        return;\n    }\n    await invoke(\"purge_model_cache\");\n};\n```\n\n## SPACE DISPLAY\n- Show model size: \"~600 MB\"\n- Show available disk space\n- Warning if low on space\n\n## WHY THIS MATTERS\nUsers need visibility into model download status. This is critical for first-run experience when multi-GB download is required.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:11:59.219272988Z","created_by":"ubuntu","updated_at":"2026-02-04T04:46:22.886734412Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1xu.4","depends_on_id":"translatorvoiceinputtool-1xu","type":"parent-child","created_at":"2026-02-04T03:11:59.219272988Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.4","depends_on_id":"translatorvoiceinputtool-t89.15","type":"blocks","created_at":"2026-02-04T04:46:22.886638283Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.4","depends_on_id":"translatorvoiceinputtool-t89.8","type":"blocks","created_at":"2026-02-04T03:20:05.308436813Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1xu.5","title":"M3.5: Replacements manager UI","description":"Implement CRUD interface for text replacement rules with presets and preview.\n\n## ACCEPTANCE CRITERIA\n- CRUD operations for replacement rules\n- Preset rule sets can be enabled/disabled\n- Presets clearly labeled in UI\n- Import/export rules as JSON\n- Live preview of replacements\n- Preview validated against shared test vectors\n\n## IMPLEMENTATION NOTES\nFiles:\n- src/components/Replacements/ReplacementList.tsx\n- src/components/Replacements/ReplacementEditor.tsx\n- src/components/Replacements/ReplacementPreview.tsx\n- src/components/Replacements/PresetsPanel.tsx\n\n## REPLACEMENT RULE SCHEMA\n```typescript\ninterface ReplacementRule {\n    id: string;\n    enabled: boolean;\n    kind: \"literal\" | \"regex\";\n    pattern: string;\n    replacement: string;\n    wordBoundary: boolean;  // For literal only\n    caseSensitive: boolean;\n    description?: string;\n    origin?: \"user\" | \"preset\";\n}\n```\n\n## LIST VIEW\n- Table or card layout\n- Columns: Pattern, Replacement, Type, Enabled toggle, Actions\n- Drag to reorder (order matters for apply sequence)\n- Preset rules show badge \"Preset\"\n- User rules show Edit/Delete buttons\n\n## EDITOR DIALOG\n```typescript\nfunction ReplacementEditor({ rule, onSave, onCancel }: Props) {\n    return (\n        <Dialog>\n            <Input label=\"Pattern\" value={rule.pattern} />\n            <Input label=\"Replacement\" value={rule.replacement} />\n            <Select label=\"Type\" options={[\"literal\", \"regex\"]} />\n            {rule.kind === \"literal\" && (\n                <Checkbox label=\"Word boundary\" checked={rule.wordBoundary} />\n            )}\n            <Checkbox label=\"Case sensitive\" checked={rule.caseSensitive} />\n            <Input label=\"Description (optional)\" value={rule.description} />\n        </Dialog>\n    );\n}\n```\n\n## PRESET PANEL\n- Toggle switches for each preset category\n- Examples: \"Common abbreviations\", \"Punctuation\", \"Profanity filter\"\n- Presets loaded from shared/replacements/PRESETS.json\n\n## LIVE PREVIEW\n```typescript\nfunction ReplacementPreview({ rules }: { rules: ReplacementRule[] }) {\n    const [input, setInput] = useState(\"\");\n    const [output, setOutput] = useState(\"\");\n    \n    useEffect(() => {\n        // Apply rules locally for instant preview\n        setOutput(applyReplacements(input, rules));\n    }, [input, rules]);\n    \n    return (\n        <div>\n            <TextArea label=\"Test input\" value={input} onChange={setInput} />\n            <div className=\"output\">Result: {output}</div>\n        </div>\n    );\n}\n```\n\n## IMPORT/EXPORT\n```typescript\nconst exportRules = () => {\n    const json = JSON.stringify(rules, null, 2);\n    downloadFile(json, \"openvoicy-replacements.json\");\n};\n\nconst importRules = async (file: File) => {\n    const content = await file.text();\n    const imported = JSON.parse(content);\n    // Validate against schema\n    // Merge or replace existing\n};\n```\n\n## WHY THIS MATTERS\nReplacement rules are a key power-user feature. Good UX for CRUD + preview makes them accessible.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:12:16.822659731Z","created_by":"ubuntu","updated_at":"2026-02-04T03:31:39.660969323Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1xu.5","depends_on_id":"translatorvoiceinputtool-1ao.7","type":"blocks","created_at":"2026-02-04T03:31:39.660883984Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.5","depends_on_id":"translatorvoiceinputtool-1ao.8","type":"blocks","created_at":"2026-02-04T03:20:05.418985891Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.5","depends_on_id":"translatorvoiceinputtool-1xu","type":"parent-child","created_at":"2026-02-04T03:12:16.822659731Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1xu.6","title":"M3.6: Diagnostics + Self-check panel","description":"Implement diagnostics export and self-check for troubleshooting.\n\n## ACCEPTANCE CRITERIA\n- Self-check reports: effective modes, permissions, sidecar status, model status, focus-guard mode\n- Diagnostics: one text blob for bug reports\n- Bounded size (max 50KB)\n- Redacts sensitive paths and transcript contents\n- Copy-to-clipboard action\n\n## IMPLEMENTATION NOTES\nFiles:\n- src/components/Settings/SelfCheck.tsx\n- src/components/Settings/Diagnostics.tsx\n\n## SELF-CHECK PANEL\n```typescript\ninterface SelfCheckResult {\n    hotkeyMode: { configured: string; effective: string; reason?: string };\n    injectionMode: { configured: string; effective: string; reason?: string };\n    permissions: {\n        microphone: \"granted\" | \"denied\" | \"unknown\";\n        accessibility?: \"granted\" | \"denied\" | \"unknown\";\n    };\n    sidecar: { status: \"running\" | \"stopped\" | \"error\"; version?: string };\n    model: { status: string; modelId?: string };\n    focusGuard: { enabled: boolean };\n}\n\nfunction SelfCheck() {\n    const [result, setResult] = useState<SelfCheckResult | null>(null);\n    \n    const runCheck = async () => {\n        setResult(await invoke(\"run_self_check\"));\n    };\n}\n```\n\n## SELF-CHECK DISPLAY\nShow each item with status icon:\n- ✅ Green check: working correctly\n- ⚠️ Yellow warning: degraded but functional\n- ❌ Red X: problem detected\n\nExamples:\n- Hotkey Mode: ✅ Hold mode (configured: hold, effective: hold)\n- Hotkey Mode: ⚠️ Toggle mode (configured: hold, effective: toggle - Wayland limitation)\n- Microphone: ❌ Permission denied - click to open settings\n- Sidecar: ✅ Running (v0.1.0)\n- Model: ⚠️ Downloading (45%)\n\n## DIAGNOSTICS EXPORT\n```typescript\ninterface DiagnosticsReport {\n    timestamp: string;\n    appVersion: string;\n    platform: string;\n    selfCheck: SelfCheckResult;\n    recentLogs: string[];  // Last 100 lines, redacted\n    config: object;  // Sanitized\n}\n\nfunction Diagnostics() {\n    const [report, setReport] = useState<string>(\"\");\n    \n    const generateReport = async () => {\n        const data = await invoke<DiagnosticsReport>(\"generate_diagnostics\");\n        setReport(formatDiagnostics(data));\n    };\n    \n    const copyReport = () => {\n        navigator.clipboard.writeText(report);\n        showToast(\"Copied to clipboard\");\n    };\n}\n```\n\n## REDACTION\nBefore export:\n- Replace home directory path: /home/user → ~\n- Remove transcript text\n- Remove any API keys (if any)\n- Truncate very long values\n\n## OUTPUT FORMAT\n```\n=== OpenVoicy Diagnostics ===\nTimestamp: 2026-02-04T15:30:00Z\nVersion: 0.1.0\nPlatform: linux-x64\n\n--- Self Check ---\nHotkey: hold (effective: toggle - Wayland)\nInjection: clipboard_paste (effective: clipboard_only)\n...\n\n--- Recent Logs ---\n[2026-02-04T15:29:00Z] INFO sidecar started\n...\n\n--- Config ---\n{\n  \"audio\": { \"device_uid\": \"...\" },\n  ...\n}\n```\n\n## WHY THIS MATTERS\nWhen users report bugs, diagnostics give developers the context needed to reproduce and fix issues.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:12:45.076762581Z","created_by":"ubuntu","updated_at":"2026-02-04T04:46:23.003542636Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1xu.6","depends_on_id":"translatorvoiceinputtool-1xu","type":"parent-child","created_at":"2026-02-04T03:12:45.076762581Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.6","depends_on_id":"translatorvoiceinputtool-t89.15","type":"blocks","created_at":"2026-02-04T04:46:23.003419486Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.6","depends_on_id":"translatorvoiceinputtool-t89.3","type":"blocks","created_at":"2026-02-04T03:20:05.539015787Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1xu.7","title":"React app state management","description":"Set up Zustand store for UI state management with Tauri event subscriptions.\n\n## ACCEPTANCE CRITERIA\n- Zustand store created with all required state slices\n- Tauri event subscriptions set up on app mount\n- Actions trigger Tauri commands\n- State updates on event notifications\n- TypeScript types for all state/actions\n\n## STATE STRUCTURE\n```typescript\ninterface AppStore {\n  // App state\n  appState: \"idle\" | \"loading_model\" | \"recording\" | \"transcribing\" | \"error\";\n  errorDetail?: string;\n  \n  // Model state\n  modelStatus: ModelStatus;\n  downloadProgress?: { current: number; total: number; unit: string };\n  \n  // Audio devices\n  devices: AudioDevice[];\n  selectedDeviceUid: string | null;\n  audioLevel: { rms: number; peak: number } | null;\n  isMeterRunning: boolean;\n  \n  // Transcript history\n  history: TranscriptEntry[];\n  \n  // Settings (mirror of Rust config)\n  settings: AppSettings;\n  \n  // Capabilities\n  capabilities: {\n    hotkeyMode: EffectiveMode;\n    injectionMode: EffectiveMode;\n    permissions: PermissionStatus;\n  } | null;\n  \n  // Self-check results\n  selfCheckResult: SelfCheckResult | null;\n}\n```\n\n## TYPE DEFINITIONS\n```typescript\ninterface ModelStatus {\n  modelId: string;\n  revision: string;\n  status: \"missing\" | \"downloading\" | \"verifying\" | \"ready\" | \"error\";\n  errorMessage?: string;\n  cachePath?: string;\n}\n\ninterface AudioDevice {\n  uid: string;\n  name: string;\n  isDefault: boolean;\n  defaultSampleRate: number;\n  channels: number;\n}\n\ninterface TranscriptEntry {\n  id: string;\n  text: string;\n  timestamp: string;\n  audioDurationMs: number;\n  transcriptionDurationMs: number;\n  injectionResult: \n    | { type: \"injected\" }\n    | { type: \"clipboardOnly\"; reason: string }\n    | { type: \"error\"; message: string };\n}\n\ninterface AppSettings {\n  audio: {\n    deviceUid: string | null;\n    audioCuesEnabled: boolean;\n  };\n  hotkeys: {\n    primary: string;\n    copyLast: string;\n    mode: \"hold\" | \"toggle\";\n  };\n  injection: {\n    pasteDelayMs: number;\n    restoreClipboard: boolean;\n    suffix: \"\" | \" \" | \"\\n\";\n    focusGuardEnabled: boolean;\n  };\n  replacements: ReplacementRule[];\n}\n\ninterface EffectiveMode {\n  configured: string;\n  effective: string;\n  reason?: string;\n}\n```\n\n## ACTIONS\n```typescript\ninterface AppActions {\n  // Device actions\n  refreshDevices: () => Promise<void>;\n  selectDevice: (uid: string | null) => Promise<void>;\n  startMeter: () => Promise<void>;\n  stopMeter: () => Promise<void>;\n  \n  // Settings actions\n  updateSetting: <K extends keyof AppSettings>(\n    section: K, \n    key: keyof AppSettings[K], \n    value: any\n  ) => Promise<void>;\n  \n  // Model actions\n  downloadModel: () => Promise<void>;\n  purgeModelCache: () => Promise<void>;\n  \n  // History actions\n  fetchHistory: () => Promise<void>;\n  copyTranscript: (id: string) => Promise<void>;\n  copyLastTranscript: () => Promise<void>;\n  \n  // Diagnostics actions\n  runSelfCheck: () => Promise<void>;\n  generateDiagnostics: () => Promise<string>;\n  \n  // Internal actions (called by event handlers)\n  _setAppState: (state: AppStore[\"appState\"], detail?: string) => void;\n  _setModelStatus: (status: ModelStatus) => void;\n  _setDownloadProgress: (progress: AppStore[\"downloadProgress\"]) => void;\n  _setAudioLevel: (level: { rms: number; peak: number }) => void;\n  _addHistoryEntry: (entry: TranscriptEntry) => void;\n}\n```\n\n## TAURI EVENT SUBSCRIPTIONS\n```typescript\n// In App.tsx or dedicated hook\nuseEffect(() => {\n  const unlisteners: (() => void)[] = [];\n  \n  // Subscribe to app state changes\n  listen<{ state: string; detail?: string }>(\"app_state_changed\", (event) => {\n    useAppStore.getState()._setAppState(event.payload.state, event.payload.detail);\n  }).then(unlisten => unlisteners.push(unlisten));\n  \n  // Subscribe to model status changes\n  listen<ModelStatus>(\"model_status_changed\", (event) => {\n    useAppStore.getState()._setModelStatus(event.payload);\n  }).then(unlisten => unlisteners.push(unlisten));\n  \n  // Subscribe to download progress\n  listen<{ current: number; total: number; unit: string }>(\"model_progress\", (event) => {\n    useAppStore.getState()._setDownloadProgress(event.payload);\n  }).then(unlisten => unlisteners.push(unlisten));\n  \n  // Subscribe to audio level\n  listen<{ rms: number; peak: number }>(\"audio_level\", (event) => {\n    useAppStore.getState()._setAudioLevel(event.payload);\n  }).then(unlisten => unlisteners.push(unlisten));\n  \n  // Subscribe to new transcripts\n  listen<TranscriptEntry>(\"transcription_complete\", (event) => {\n    useAppStore.getState()._addHistoryEntry(event.payload);\n  }).then(unlisten => unlisteners.push(unlisten));\n  \n  // Cleanup on unmount\n  return () => {\n    unlisteners.forEach(unlisten => unlisten());\n  };\n}, []);\n```\n\n## STORE IMPLEMENTATION\n```typescript\nimport { create } from \"zustand\";\nimport { invoke } from \"@tauri-apps/api/core\";\n\nconst useAppStore = create<AppStore & AppActions>((set, get) => ({\n  // Initial state\n  appState: \"idle\",\n  modelStatus: { modelId: \"\", revision: \"\", status: \"missing\" },\n  devices: [],\n  selectedDeviceUid: null,\n  audioLevel: null,\n  isMeterRunning: false,\n  history: [],\n  settings: { /* defaults */ },\n  capabilities: null,\n  selfCheckResult: null,\n  \n  // Actions\n  refreshDevices: async () => {\n    const devices = await invoke<AudioDevice[]>(\"get_audio_devices\");\n    set({ devices });\n  },\n  \n  selectDevice: async (uid) => {\n    await invoke(\"set_audio_device\", { deviceUid: uid });\n    set({ selectedDeviceUid: uid });\n  },\n  \n  // ... other actions\n}));\n```\n\n## INITIALIZATION\nOn app load:\n1. Fetch initial state from Rust (settings, capabilities, history, model status)\n2. Set up event listeners\n3. Refresh device list\n\n## ERROR HANDLING\n- Actions that call Tauri commands should catch errors\n- Display errors via toast or error state\n- Settings updates should rollback on failure\n\n## TEST REQUIREMENTS\n- Test store initial state\n- Test action state updates\n- Test event handler state updates\n- Mock Tauri APIs for unit tests\n\n## WHY THIS MATTERS\nCentralized state management ensures UI stays in sync with Rust backend. Zustand is lightweight and TypeScript-friendly, perfect for Tauri apps.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:18:20.051230591Z","created_by":"ubuntu","updated_at":"2026-02-04T03:44:37.942947653Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1xu.7","depends_on_id":"translatorvoiceinputtool-1ao.1","type":"blocks","created_at":"2026-02-04T03:20:37.706433358Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.7","depends_on_id":"translatorvoiceinputtool-1xu","type":"parent-child","created_at":"2026-02-04T03:18:20.051230591Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-1xu.8","title":"React/TypeScript unit tests","description":"Implement comprehensive React/TypeScript unit and integration tests.\n\n## ACCEPTANCE CRITERIA\n- All major components have unit tests\n- Zustand store has unit tests for all actions\n- Replacement rule preview matches shared test vectors exactly\n- Tauri command mocking for isolated tests\n- Test coverage for error states and edge cases\n- CI runs tests on every PR\n\n## TEST FRAMEWORK\n- Vitest (Vite-native, fast)\n- React Testing Library for component tests\n- MSW (Mock Service Worker) or manual mocks for Tauri APIs\n\n## COMPONENTS TO TEST\n\n### Core Components\n- StatusIndicator: renders all states correctly\n- HistoryPanel: displays transcripts, copy actions work\n- TranscriptCard: shows injected vs clipboard-only badges\n\n### Settings Components  \n- MicrophoneSelect: device list, selection persistence\n- HotkeyConfig: mode selection, effective mode display\n- InjectionSettings: all toggles and sliders\n- ModelSettings: status display, download/purge actions\n\n### Replacements Components\n- ReplacementList: CRUD operations, reordering\n- ReplacementEditor: validation, save/cancel\n- ReplacementPreview: live preview matches test vectors\n\n### Diagnostics Components\n- SelfCheck: displays all check items correctly\n- Diagnostics: generates report, copy works\n\n## ZUSTAND STORE TESTS\n```typescript\ndescribe('useAppStore', () => {\n  beforeEach(() => {\n    useAppStore.setState(initialState);\n  });\n\n  test('refreshDevices updates device list', async () => {\n    mockInvoke('get_audio_devices', mockDevices);\n    await useAppStore.getState().refreshDevices();\n    expect(useAppStore.getState().devices).toEqual(mockDevices);\n  });\n\n  test('selectDevice calls Tauri and updates state', async () => {\n    mockInvoke('set_audio_device');\n    await useAppStore.getState().selectDevice('test-uid');\n    expect(invoke).toHaveBeenCalledWith('set_audio_device', { deviceUid: 'test-uid' });\n    expect(useAppStore.getState().selectedDeviceUid).toBe('test-uid');\n  });\n\n  test('selectDevice rolls back on error', async () => {\n    useAppStore.setState({ selectedDeviceUid: 'original' });\n    mockInvokeError('set_audio_device', new Error('Device not found'));\n    await expect(useAppStore.getState().selectDevice('bad-uid')).rejects.toThrow();\n    expect(useAppStore.getState().selectedDeviceUid).toBe('original');\n  });\n});\n```\n\n## SHARED TEST VECTOR VALIDATION\nThe replacement preview component MUST produce identical output to the sidecar:\n\n```typescript\nimport TEST_VECTORS from '../../shared/replacements/TEST_VECTORS.json';\n\ndescribe('ReplacementPreview', () => {\n  test.each(TEST_VECTORS.test_cases)('$name', ({ input, rules, expected, expected_pattern }) => {\n    const result = applyReplacements(input, rules);\n    if (expected_pattern) {\n      expect(result).toMatch(new RegExp(expected_pattern));\n    } else {\n      expect(result).toBe(expected);\n    }\n  });\n});\n```\n\n## TAURI MOCK SETUP\n```typescript\n// tests/setup.ts\nimport { vi } from 'vitest';\n\nconst mockInvoke = vi.fn();\nconst mockListen = vi.fn();\n\nvi.mock('@tauri-apps/api/core', () => ({\n  invoke: mockInvoke,\n}));\n\nvi.mock('@tauri-apps/api/event', () => ({\n  listen: mockListen,\n}));\n\nexport { mockInvoke, mockListen };\n```\n\n## ERROR STATE TESTS\nTest that components handle error scenarios gracefully:\n- Network failures during model download\n- Invalid device selection\n- Sidecar not reachable\n- Permission denied states\n\n## SNAPSHOT TESTS (optional)\nFor complex components like Diagnostics output:\n```typescript\ntest('diagnostics report format', async () => {\n  const report = await generateDiagnosticsReport(mockData);\n  expect(report).toMatchSnapshot();\n});\n```\n\n## CI INTEGRATION\n- npm test runs all UI tests\n- Tests must pass before merge\n- Coverage report generated\n- Shared test vector validation included\n\n## FILE STRUCTURE\n```\nsrc/\n  components/\n    __tests__/\n      StatusIndicator.test.tsx\n      HistoryPanel.test.tsx\n      ...\n  stores/\n    __tests__/\n      appStore.test.ts\n  lib/\n    __tests__/\n      replacements.test.ts  // shared test vector validation\ntests/\n  setup.ts\n  mocks/\n    tauri.ts\nvitest.config.ts\n```\n\n## TEST REQUIREMENTS\n- Minimum 80% coverage for store actions\n- All shared test vectors pass\n- All error states tested\n- No flaky tests\n\n## WHY THIS MATTERS\nUI tests prevent regressions in user-facing components. The shared test vector validation ensures the preview matches actual sidecar behavior - users expect what they see in preview to match what gets injected.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:51:36.614612532Z","created_by":"ubuntu","updated_at":"2026-02-04T03:51:41.723752189Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-1xu.8","depends_on_id":"translatorvoiceinputtool-1ao.8","type":"blocks","created_at":"2026-02-04T03:51:41.634636737Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.8","depends_on_id":"translatorvoiceinputtool-1xu","type":"parent-child","created_at":"2026-02-04T03:51:36.614612532Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-1xu.8","depends_on_id":"translatorvoiceinputtool-1xu.7","type":"blocks","created_at":"2026-02-04T03:51:41.723675837Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-6pe","title":"M4: End-to-End Integration + Hardening","description":"MILESTONE M4 (Day 4-5): Ship-grade MVP behavior and error handling.\n\n## PURPOSE\nWire together all components (hotkey → record → transcribe → inject) and implement comprehensive error handling for all failure modes. This is the \"make it bulletproof\" phase.\n\n## KEY DELIVERABLES\n- Full E2E flow working without UI open (tray + hotkey only)\n- Error handling matrix fully implemented\n- Logging with ring-buffer for diagnostics\n- Manual checklist finalized\n\n## ERROR HANDLING MATRIX\nAll of these scenarios must yield user-actionable messages with deterministic reproduction:\n- No microphone available\n- Microphone permission denied\n- Sidecar crash\n- Sidecar hang (watchdog triggers)\n- Model download failure (network/disk)\n- Model load failure\n- Hotkey conflict with another app\n- Injection blocked (e.g., Wayland constraints)\n- Focus changed between stop and inject\n- Rapid press/release (debounce)\n\n## TESTING APPROACH\n- Each error scenario has a documented reproduction method\n- Manual checklist includes first-run model download + offline verification\n- OS-specific permission steps documented\n- Wayland limitations documented\n- Focus Guard behavior verified\n\n## DOCUMENTATION DELIVERABLES\n- docs/MANUAL_CHECKLIST.md finalized\n- docs/KNOWN_LIMITATIONS.md complete","status":"open","priority":1,"issue_type":"epic","created_at":"2026-02-04T03:03:00.225613205Z","created_by":"ubuntu","updated_at":"2026-02-04T03:03:00.225613205Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"translatorvoiceinputtool-6pe.1","title":"M4.1: Wire hotkey → record → transcribe → inject E2E","description":"Complete end-to-end integration of the core transcription flow.\n\n## ACCEPTANCE CRITERIA\n- Works without UI window open (tray + hotkey only)\n- Tray reflects states: idle → recording → transcribing → idle\n- Full flow: press hotkey → record → release → transcribe → inject\n- Handles both hold and toggle modes\n- Audio cues play at correct moments\n\n## IMPLEMENTATION NOTES\nThis task wires together all the components:\n- M2.7 (hotkey) → M2.4 (recording) → M1.6 (ASR) → M1.7 (postprocess) → M2.5 (injection)\n\n## TEST SCENARIO\n1. Start app (no UI window)\n2. Verify tray icon shows idle\n3. Press and hold hotkey\n4. Verify tray shows recording, audio cue plays\n5. Speak: \"Hello world\"\n6. Release hotkey\n7. Verify tray shows transcribing, stop cue plays\n8. Wait for transcription\n9. Verify tray returns to idle\n10. Verify \"Hello world\" was injected into focused app\n\n## EDGE CASES TO HANDLE\n- Very short recording (< 250ms): show \"recording too short\" message\n- Very long recording (> 60s): auto-stop and continue to transcription\n- Transcription takes too long (> 60s): timeout error with remediation\n- ASR returns empty string: inject nothing, no error\n- Model not ready: show error, do not try to record\n\n## TRAY ICON UPDATES\n```rust\nfn update_tray_for_state(state: AppState) {\n    let icon = match state {\n        AppState::Idle => \"tray-idle.png\",\n        AppState::Recording => \"tray-recording.png\",\n        AppState::Transcribing => \"tray-transcribing.png\",\n        AppState::LoadingModel => \"tray-loading.png\",\n        AppState::Error => \"tray-error.png\",\n    };\n    set_tray_icon(icon);\n}\n```\n\n## INTEGRATION TEST\nCreate manual test script:\n1. Build app\n2. Run with no UI\n3. Execute test scenario\n4. Verify injection in target app\n5. Check logs for any errors\n\n## WHY THIS MATTERS\nThis is the core product experience. Everything else supports this flow.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:13:06.238011115Z","created_by":"ubuntu","updated_at":"2026-02-04T03:20:14.897623971Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-6pe.1","depends_on_id":"translatorvoiceinputtool-13v.8","type":"blocks","created_at":"2026-02-04T03:20:14.685274765Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.1","depends_on_id":"translatorvoiceinputtool-6pe","type":"parent-child","created_at":"2026-02-04T03:13:06.238011115Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.1","depends_on_id":"translatorvoiceinputtool-t89.5","type":"blocks","created_at":"2026-02-04T03:20:14.778260867Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.1","depends_on_id":"translatorvoiceinputtool-t89.7","type":"blocks","created_at":"2026-02-04T03:20:14.897547318Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-6pe.2","title":"M4.2: Error handling matrix implementation","description":"Implement comprehensive error handling for all failure scenarios.\n\n## ACCEPTANCE CRITERIA\n- Each error scenario yields user-actionable message\n- Deterministic reproduction steps in manual checklist\n- Error kinds mapped to stable remediation text (version-controlled)\n- Errors visible via tray notification and/or UI\n- Error messages localized to error kinds (not raw exception text)\n\n## ERROR SCENARIOS (COMPLETE LIST - ALL MUST BE HANDLED)\n\n### Hardware/Permission Errors\n1. **No microphone available**\n   - Detection: audio.list_devices returns empty\n   - Message: \"No microphone found. Connect a microphone and restart.\"\n   - Remediation: Link to troubleshooting docs\n   - Error kind: E_DEVICE_NOT_FOUND\n\n2. **Microphone permission denied**\n   - Detection: E_MIC_PERMISSION error from sidecar\n   - Message: \"Microphone permission required. Click to open settings.\"\n   - Remediation: Platform-specific settings deep link\n   - Error kind: E_MIC_PERMISSION\n\n3. **Device disconnected during recording**\n   - Detection: E_AUDIO_IO error during recording\n   - Message: \"Microphone disconnected. Recording cancelled.\"\n   - Action: Auto-transition to idle, discard partial recording\n   - Error kind: E_AUDIO_IO\n\n4. **Selected device no longer available**\n   - Detection: audio.set_device fails with E_DEVICE_NOT_FOUND\n   - Message: \"Previously selected microphone not found. Using default.\"\n   - Action: Fall back to default device\n   - Error kind: E_DEVICE_NOT_FOUND\n\n### Sidecar Errors\n5. **Sidecar crash**\n   - Detection: Process exit, stdout closed\n   - Message: \"Background service crashed. Restarting...\"\n   - Action: Auto-restart with backoff\n   - Error kind: E_INTERNAL\n\n6. **Sidecar hang (watchdog)**\n   - Detection: Watchdog ping timeout (30s without response)\n   - Message: \"Background service not responding. Restarting...\"\n   - Action: Kill and restart\n   - Error kind: E_INTERNAL\n\n7. **Sidecar max retries exceeded**\n   - Detection: Restart count > 5\n   - Message: \"Background service failed repeatedly. Click to retry or restart app.\"\n   - Remediation: Manual retry button, suggest reinstall if persists\n   - Error kind: E_INTERNAL\n\n### Model Errors\n8. **Model download failed (network)**\n   - Detection: E_NETWORK error during download\n   - Message: \"Download failed. Check internet connection.\"\n   - Remediation: Retry button, show partial progress if resumable\n   - Error kind: E_NETWORK\n\n9. **Model download failed (disk full)**\n   - Detection: E_DISK_FULL error with required_bytes in details\n   - Message: \"Not enough disk space. Need {X} GB free.\"\n   - Remediation: Disk cleanup suggestions, show required vs available\n   - Error kind: E_DISK_FULL\n\n10. **Model cache corrupted**\n    - Detection: E_CACHE_CORRUPT error (hash mismatch)\n    - Message: \"Model files corrupted. Re-downloading...\"\n    - Action: Auto-purge and retry download\n    - Error kind: E_CACHE_CORRUPT\n\n11. **Model load failed**\n    - Detection: E_MODEL_LOAD error\n    - Message: \"Failed to load model. Click to re-download.\"\n    - Action: Purge cache and retry\n    - Error kind: E_MODEL_LOAD\n\n12. **Model purge rejected (in use)**\n    - Detection: E_NOT_READY from model.purge_cache\n    - Message: \"Cannot purge model while transcription is in progress. Try again later.\"\n    - Action: User must wait and retry\n    - Error kind: E_NOT_READY\n\n### Hotkey Errors\n13. **Hotkey conflict**\n    - Detection: Registration fails\n    - Message: \"Hotkey [{X}] is in use by another app. Click to change.\"\n    - Remediation: Open hotkey settings\n    - Error kind: (Rust-side, no IPC error kind)\n\n14. **Wayland portal unavailable**\n    - Detection: Portal check fails on Wayland\n    - Message: \"Global shortcuts not available. App will run in limited mode.\"\n    - Remediation: Explain limitation, suggest X11 or different DE\n    - Error kind: (Rust-side detection)\n\n### Injection Errors\n15. **Injection blocked (Wayland)**\n    - Detection: Effective mode = clipboard_only on Wayland\n    - Message: \"Cannot inject text on Wayland. Copied to clipboard instead.\"\n    - Remediation: Explain limitation\n    - Error kind: (not error, just mode degradation)\n\n16. **Focus changed (Focus Guard)**\n    - Detection: Focus signature mismatch at inject time\n    - Message: \"Window changed during transcription. Text copied to clipboard.\"\n    - Action: Clipboard-only, warning notification\n    - Error kind: (not error, Focus Guard behavior)\n\n17. **Self-injection prevented**\n    - Detection: OpenVoicy window focused at inject time\n    - Message: \"Settings window focused. Text copied to clipboard.\"\n    - Action: Clipboard-only, info notification\n    - Error kind: (not error, safety behavior)\n\n18. **Accessibility permission denied (macOS)**\n    - Detection: CGPreflightListenEventAccess returns false\n    - Message: \"Accessibility permission required for text injection. Click to open settings.\"\n    - Remediation: System Preferences > Security > Accessibility\n    - Error kind: (Rust-side detection)\n\n### Recording Errors\n19. **Rapid press/release (too short)**\n    - Detection: Duration < 250ms\n    - Message: \"Recording too short. Hold longer or use toggle mode.\"\n    - Action: No-op, no transcription, no error state\n    - Error kind: (not error, just ignored)\n\n20. **Max duration reached**\n    - Detection: Recording exceeds 60s (or hard cap 300s)\n    - Message: \"Maximum recording length reached. Processing...\"\n    - Action: Auto-stop and continue to transcription\n    - Error kind: (not error, just auto-behavior)\n\n21. **Transcription timeout**\n    - Detection: No transcription event 60s after stop\n    - Message: \"Transcription timed out. Click to restart service.\"\n    - Action: Transition to error state, offer restart\n    - Error kind: E_INTERNAL\n\n22. **Transcription failed**\n    - Detection: E_TRANSCRIBE error from sidecar\n    - Message: \"Transcription failed. Recording discarded.\"\n    - Action: Transition to error state, log details\n    - Error kind: E_TRANSCRIBE\n\n### Startup Errors\n23. **Sidecar executable missing**\n    - Detection: Spawn fails, file not found\n    - Message: \"Application files missing. Please reinstall.\"\n    - Remediation: Reinstall instructions\n    - Error kind: (Rust-side)\n\n24. **Sidecar quarantine (macOS)**\n    - Detection: Spawn fails with permission/quarantine error\n    - Message: \"Background service blocked by macOS. Open settings to allow.\"\n    - Remediation: Gatekeeper instructions\n    - Error kind: (Rust-side)\n\n## IMPLEMENTATION\n```rust\npub struct UserError {\n    pub title: String,\n    pub message: String,\n    pub error_kind: Option<ErrorKind>,\n    pub remediation: Option<Remediation>,\n    pub details: Option<String>,  // For diagnostics, not shown to user\n}\n\npub enum Remediation {\n    OpenSettings(SettingsPage),\n    OpenUrl(String),\n    Retry,\n    RestartSidecar,\n    RestartApp,\n    Reinstall,\n    None,\n}\n\nfn map_error_to_user_message(error: AppError) -> UserError {\n    match error {\n        AppError::Sidecar(SidecarError::NoMicrophone) => UserError {\n            title: \"No Microphone\".into(),\n            message: \"No microphone found. Connect a microphone and restart.\".into(),\n            error_kind: Some(ErrorKind::DeviceNotFound),\n            remediation: Some(Remediation::OpenUrl(\"docs/troubleshooting/no-mic\".into())),\n            details: None,\n        },\n        // ... all other mappings\n    }\n}\n```\n\n## REMEDIATION TEXT SOURCE\nAll remediation text is version-controlled in:\n- src-tauri/src/errors/remediation.rs (Rust messages)\n- Keyed by stable error categories\n- Testable: unit tests verify all error kinds have remediation text\n\n## TEST REQUIREMENTS\n- Unit test: each error kind maps to non-empty message\n- Unit test: each error kind has remediation (where applicable)\n- Unit test: error messages don't contain stack traces or paths\n- Integration test: trigger each error scenario, verify user message\n- Manual test: each scenario in MANUAL_CHECKLIST.md\n\n## WHY THIS MATTERS\nEvery error must have a clear path to resolution. Silent failures destroy user trust. Consistent remediation text makes support easier.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:13:27.556484415Z","created_by":"ubuntu","updated_at":"2026-02-04T04:40:53.625780279Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-6pe.2","depends_on_id":"translatorvoiceinputtool-6pe","type":"parent-child","created_at":"2026-02-04T03:13:27.556484415Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.2","depends_on_id":"translatorvoiceinputtool-6pe.1","type":"blocks","created_at":"2026-02-04T03:20:14.984993793Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-6pe.3","title":"M4.3: Logging with ring buffer for diagnostics","description":"Implement bounded logging for diagnostic export.\n\n## ACCEPTANCE CRITERIA\n- Ring buffer holds last 500 lines or 256 KiB (whichever comes first)\n- Log levels: trace, debug, info, warn, error\n- Production builds log at info level by default\n- Logs available for diagnostics export\n- Sensitive items redacted before export\n\n## IMPLEMENTATION NOTES\nFile: src-tauri/src/logging.rs\n\n## RING BUFFER IMPLEMENTATION\n```rust\npub struct LogBuffer {\n    entries: VecDeque<LogEntry>,\n    max_entries: usize,\n    max_bytes: usize,\n    current_bytes: usize,\n}\n\npub struct LogEntry {\n    timestamp: DateTime<Utc>,\n    level: Level,\n    target: String,\n    message: String,\n}\n\nimpl LogBuffer {\n    pub fn push(&mut self, entry: LogEntry) {\n        let entry_size = entry.message.len() + entry.target.len() + 64;\n        \n        // Remove old entries if we exceed limits\n        while self.entries.len() >= self.max_entries \n            || self.current_bytes + entry_size > self.max_bytes {\n            if let Some(old) = self.entries.pop_front() {\n                self.current_bytes -= old.size();\n            } else {\n                break;\n            }\n        }\n        \n        self.current_bytes += entry_size;\n        self.entries.push_back(entry);\n    }\n}\n```\n\n## LOG SUBSCRIBER\nUse tracing crate with custom subscriber:\n```rust\npub fn init_logging(buffer: Arc<Mutex<LogBuffer>>) {\n    let subscriber = tracing_subscriber::fmt()\n        .with_max_level(Level::INFO)\n        .with_writer(BufferWriter(buffer.clone()))\n        .finish();\n    \n    tracing::subscriber::set_global_default(subscriber).unwrap();\n}\n```\n\n## REDACTION BEFORE EXPORT\n```rust\nfn redact_log_entry(entry: &LogEntry) -> String {\n    let mut message = entry.message.clone();\n    \n    // Redact home directory\n    message = message.replace(&home_dir(), \"~\");\n    \n    // Redact potential secrets\n    message = SENSITIVE_PATTERN.replace_all(&message, \"[REDACTED]\").to_string();\n    \n    format\\!(\"[{}] {} - {}\", entry.timestamp, entry.level, message)\n}\n```\n\n## SIDECAR LOGGING\n- Sidecar logs to stderr\n- Rust captures stderr and feeds into log buffer\n- Prefix sidecar logs with [sidecar]\n\n## LOG FORMAT\n```\n[2026-02-04T15:30:00Z] INFO openvoicy::sidecar - Started sidecar process\n[2026-02-04T15:30:01Z] INFO [sidecar] - Ready, protocol v1\n[2026-02-04T15:30:05Z] DEBUG openvoicy::recording - Session abc123 started\n```\n\n## TESTING\n- Verify buffer does not exceed limits\n- Verify oldest entries evicted first\n- Verify redaction works for paths\n\n## WHY THIS MATTERS\nLogs are essential for debugging. Bounded size prevents memory bloat. Redaction protects privacy.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:13:51.513139693Z","created_by":"ubuntu","updated_at":"2026-02-04T03:31:49.815990901Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-6pe.3","depends_on_id":"translatorvoiceinputtool-6pe","type":"parent-child","created_at":"2026-02-04T03:13:51.513139693Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.3","depends_on_id":"translatorvoiceinputtool-t89.1","type":"blocks","created_at":"2026-02-04T03:20:15.097891166Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.3","depends_on_id":"translatorvoiceinputtool-t89.2","type":"blocks","created_at":"2026-02-04T03:31:49.815887167Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-6pe.4","title":"M4.4: Manual checklist finalized","description":"Create comprehensive manual testing checklist for MVP validation.\n\n## ACCEPTANCE CRITERIA\n- Checklist covers first-run model download\n- Checklist covers offline verification\n- OS-specific permission steps documented\n- Wayland limitations documented\n- Focus Guard behavior verified\n- Checklist is step-by-step, reproducible\n\n## IMPLEMENTATION\nFile: docs/MANUAL_CHECKLIST.md\n\n## CHECKLIST SECTIONS\n\n### 1. First Run Experience\n- [ ] Fresh install (no prior config)\n- [ ] App launches, tray icon visible\n- [ ] Settings window opens\n- [ ] Model status shows \"missing\"\n- [ ] Click \"Download\" starts download\n- [ ] Progress updates visible\n- [ ] Download completes, status shows \"ready\"\n\n### 2. Offline Verification\n- [ ] Disable network at OS level\n- [ ] Launch app (or restart)\n- [ ] Confirm model status is \"ready\"\n- [ ] Perform transcription\n- [ ] Transcription succeeds without network\n- [ ] Re-enable network\n\n### 3. Basic Transcription (Windows)\n- [ ] Open Notepad or similar text app\n- [ ] Press and hold Ctrl+Shift+Space\n- [ ] Speak \"Hello world\"\n- [ ] Release hotkey\n- [ ] Text appears in Notepad\n- [ ] Verify \"Hello world\" or similar in history\n\n### 4. Basic Transcription (macOS)\n- [ ] Grant Microphone permission when prompted\n- [ ] Grant Accessibility permission when prompted\n- [ ] Open TextEdit\n- [ ] Press and hold hotkey\n- [ ] Speak, release\n- [ ] Text appears\n\n### 5. Basic Transcription (Linux X11)\n- [ ] Open gedit or terminal\n- [ ] Press and hold hotkey\n- [ ] Speak, release\n- [ ] Text appears\n\n### 6. Wayland Limitations (Linux)\n- [ ] App detects Wayland environment\n- [ ] Self-check shows toggle mode (hold unavailable)\n- [ ] Self-check shows clipboard-only injection\n- [ ] Press hotkey (toggle on), speak, press again (toggle off)\n- [ ] Text copied to clipboard (not injected)\n- [ ] Paste manually works\n\n### 7. Focus Guard Behavior\n- [ ] Open text editor\n- [ ] Start recording\n- [ ] Switch to different app while recording\n- [ ] Release/stop recording\n- [ ] Verify clipboard-only notification\n- [ ] Verify text on clipboard, not injected in wrong app\n\n### 8. Error Recovery\n- [ ] Disconnect microphone during recording\n- [ ] Verify error message appears\n- [ ] Reconnect microphone\n- [ ] Verify recording works again\n\n### 9. Settings Persistence\n- [ ] Change hotkey\n- [ ] Change microphone\n- [ ] Quit app\n- [ ] Restart app\n- [ ] Verify settings persisted\n\n### 10. Sidecar Restart\n- [ ] Force-kill sidecar process\n- [ ] Observe restart notification\n- [ ] Verify transcription works after restart\n\n## WHY THIS MATTERS\nThe manual checklist ensures consistent MVP validation across testers and releases.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:14:11.443538396Z","created_by":"ubuntu","updated_at":"2026-02-04T03:20:15.295965848Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-6pe.4","depends_on_id":"translatorvoiceinputtool-6pe","type":"parent-child","created_at":"2026-02-04T03:14:11.443538396Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.4","depends_on_id":"translatorvoiceinputtool-6pe.1","type":"blocks","created_at":"2026-02-04T03:20:15.207723251Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.4","depends_on_id":"translatorvoiceinputtool-6pe.2","type":"blocks","created_at":"2026-02-04T03:20:15.295887472Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-6pe.5","title":"Known limitations documentation","description":"Create docs/KNOWN_LIMITATIONS.md with platform-specific constraints.\n\n## SECTIONS\n\n### Windows\n- Generally full functionality\n- Antivirus may flag sidecar (remediation steps)\n\n### macOS\n- Requires Microphone permission\n- Requires Accessibility permission for global hotkeys\n- First launch may trigger Gatekeeper\n\n### Linux X11\n- Generally full functionality\n- May need xdotool installed for injection\n\n### Linux Wayland\n- Hotkey: toggle mode only (no key-up events)\n- Injection: clipboard only (no keystroke synthesis)\n- Recommend X11 session for full experience\n\n## FORMAT\nUser-friendly language, step-by-step remediation for each limitation. Referenced from Diagnostics panel.","status":"open","priority":3,"issue_type":"task","created_at":"2026-02-04T03:18:29.803695026Z","created_by":"ubuntu","updated_at":"2026-02-04T03:20:37.807633799Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-6pe.5","depends_on_id":"translatorvoiceinputtool-1ao.4","type":"blocks","created_at":"2026-02-04T03:20:37.807535796Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.5","depends_on_id":"translatorvoiceinputtool-6pe","type":"parent-child","created_at":"2026-02-04T03:18:29.803695026Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-6pe.6","title":"Privacy documentation","description":"Create docs/PRIVACY.md explaining data handling.\n\n## CONTENT\n\n### What is stored\n- Configuration file (settings, hotkeys, replacement rules)\n- Model cache (ASR model files)\n- Logs (bounded ring buffer, not persisted by default)\n\n### What is NOT stored\n- Transcript history is in-memory only\n- No audio recordings saved\n- No cloud sync or telemetry\n\n### Data locations\n- Config: OS config directory\n- Cache: OS cache directory  \n- Logs: OS log directory (if enabled)\n\n### How to clear data\n- Instructions for complete removal\n- Purge cache function in UI\n\n## MVP SCOPE\nEmphasize privacy-by-default approach. Future opt-in persistence will have explicit messaging.","status":"open","priority":3,"issue_type":"task","created_at":"2026-02-04T03:18:39.460423970Z","created_by":"ubuntu","updated_at":"2026-02-04T03:18:39.460423970Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-6pe.6","depends_on_id":"translatorvoiceinputtool-6pe","type":"parent-child","created_at":"2026-02-04T03:18:39.460423970Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-6pe.7","title":"E2E test scripts with detailed logging","description":"Implement comprehensive E2E test scripts with detailed structured logging.\n\n## ACCEPTANCE CRITERIA\n- Scripts cover full transcription flow\n- Detailed, timestamped logging for each step\n- JSON-structured log output for parsing\n- Tests run on all target platforms\n- Offline mode verification included\n- Model cache verification included\n- Error scenarios covered\n- Exit codes indicate pass/fail\n\n## TEST SCRIPTS\n\n### scripts/e2e/test-full-flow.sh\nFull happy-path test:\n1. Start app (verify tray appears)\n2. Verify model status (download if needed)\n3. Wait for model ready\n4. Trigger recording via simulated hotkey or API\n5. Inject test audio (synthetic or file)\n6. Verify transcription complete\n7. Verify text injection or clipboard\n\n### scripts/e2e/test-offline.sh  \nOffline verification:\n1. Ensure model is cached\n2. Disable network (OS-level)\n3. Start app\n4. Verify model status is \"ready\" (not \"missing\")\n5. Perform transcription\n6. Verify success without network\n7. Re-enable network\n\n### scripts/e2e/test-error-recovery.sh\nError handling:\n1. Start app\n2. Kill sidecar process\n3. Verify error detected and restart triggered\n4. Verify transcription works after recovery\n\n### scripts/e2e/test-focus-guard.sh\nFocus Guard behavior:\n1. Start app with Focus Guard enabled\n2. Start recording\n3. Switch focus to different window during recording\n4. Stop recording\n5. Verify clipboard-only behavior\n6. Verify warning message\n\n## LOGGING FORMAT (JSON Lines)\nEach log entry is a JSON object on its own line:\n\n```json\n{\"ts\":\"2026-02-04T15:30:00.123Z\",\"level\":\"INFO\",\"phase\":\"startup\",\"step\":\"tray_check\",\"msg\":\"Tray icon visible\",\"duration_ms\":null}\n{\"ts\":\"2026-02-04T15:30:00.456Z\",\"level\":\"INFO\",\"phase\":\"startup\",\"step\":\"model_status\",\"msg\":\"Model status: ready\",\"data\":{\"model_id\":\"parakeet-tdt-0.6b-v3\",\"status\":\"ready\"}}\n{\"ts\":\"2026-02-04T15:30:01.000Z\",\"level\":\"INFO\",\"phase\":\"transcription\",\"step\":\"recording_start\",\"msg\":\"Recording started\",\"data\":{\"session_id\":\"abc-123\"}}\n{\"ts\":\"2026-02-04T15:30:03.500Z\",\"level\":\"INFO\",\"phase\":\"transcription\",\"step\":\"recording_stop\",\"msg\":\"Recording stopped\",\"data\":{\"session_id\":\"abc-123\",\"duration_ms\":2500}}\n{\"ts\":\"2026-02-04T15:30:04.200Z\",\"level\":\"INFO\",\"phase\":\"transcription\",\"step\":\"transcription_complete\",\"msg\":\"Transcription complete\",\"data\":{\"session_id\":\"abc-123\",\"text\":\"Hello world\",\"transcription_ms\":700}}\n{\"ts\":\"2026-02-04T15:30:04.250Z\",\"level\":\"INFO\",\"phase\":\"injection\",\"step\":\"inject_start\",\"msg\":\"Injecting text\",\"data\":{\"method\":\"clipboard_paste\",\"text_length\":11}}\n{\"ts\":\"2026-02-04T15:30:04.300Z\",\"level\":\"INFO\",\"phase\":\"injection\",\"step\":\"inject_complete\",\"msg\":\"Injection complete\",\"data\":{\"success\":true}}\n{\"ts\":\"2026-02-04T15:30:04.350Z\",\"level\":\"INFO\",\"phase\":\"test\",\"step\":\"verify_result\",\"msg\":\"Test PASSED\",\"data\":{\"expected\":\"Hello world\",\"actual\":\"Hello world\",\"match\":true}}\n```\n\n## LOG FIELDS\n- **ts**: ISO-8601 timestamp with milliseconds\n- **level**: DEBUG, INFO, WARN, ERROR\n- **phase**: startup, model, transcription, injection, test, cleanup\n- **step**: specific step within phase\n- **msg**: human-readable message\n- **duration_ms**: optional timing information\n- **data**: optional structured data object\n\n## LOGGING HELPER (Bash)\n```bash\n#!/bin/bash\n# scripts/e2e/lib/log.sh\n\nlog_json() {\n    local level=\"$1\"\n    local phase=\"$2\"\n    local step=\"$3\"\n    local msg=\"$4\"\n    local data=\"${5:-null}\"\n    \n    local ts=$(date -u +\"%Y-%m-%dT%H:%M:%S.%3NZ\")\n    \n    jq -nc \\\n        --arg ts \"$ts\" \\\n        --arg level \"$level\" \\\n        --arg phase \"$phase\" \\\n        --arg step \"$step\" \\\n        --arg msg \"$msg\" \\\n        --argjson data \"$data\" \\\n        '{ts:$ts, level:$level, phase:$phase, step:$step, msg:$msg, data:$data}'\n}\n\nlog_info() { log_json \"INFO\" \"$@\"; }\nlog_warn() { log_json \"WARN\" \"$@\"; }\nlog_error() { log_json \"ERROR\" \"$@\"; }\n\n# Usage:\n# log_info \"transcription\" \"recording_start\" \"Recording started\" '{\"session_id\":\"abc\"}'\n```\n\n## TIMING MEASUREMENTS\nEvery operation should be timed:\n```bash\nstart_time=$(date +%s%3N)\n# ... operation ...\nend_time=$(date +%s%3N)\nduration_ms=$((end_time - start_time))\nlog_info \"transcription\" \"asr_inference\" \"ASR complete\" \"{\\\"duration_ms\\\":$duration_ms}\"\n```\n\n## ASSERTIONS\n```bash\nassert_eq() {\n    local expected=\"$1\"\n    local actual=\"$2\"\n    local msg=\"$3\"\n    \n    if [ \"$expected\" = \"$actual\" ]; then\n        log_info \"test\" \"assert\" \"PASS: $msg\" \"{\\\"expected\\\":\\\"$expected\\\",\\\"actual\\\":\\\"$actual\\\"}\"\n        return 0\n    else\n        log_error \"test\" \"assert\" \"FAIL: $msg\" \"{\\\"expected\\\":\\\"$expected\\\",\\\"actual\\\":\\\"$actual\\\"}\"\n        return 1\n    fi\n}\n\nassert_contains() {\n    local haystack=\"$1\"\n    local needle=\"$2\"\n    local msg=\"$3\"\n    \n    if [[ \"$haystack\" == *\"$needle\"* ]]; then\n        log_info \"test\" \"assert\" \"PASS: $msg contains $needle\"\n        return 0\n    else\n        log_error \"test\" \"assert\" \"FAIL: $msg does not contain $needle\"\n        return 1\n    fi\n}\n```\n\n## OUTPUT FILES\nEach test run creates:\n- logs/e2e/{test-name}_{timestamp}.jsonl - JSON log lines\n- logs/e2e/{test-name}_{timestamp}.log - human-readable summary\n- artifacts/e2e/{test-name}_{timestamp}/ - screenshots, audio files, etc.\n\n## CI INTEGRATION\n- E2E tests run on merge to main\n- Artifacts uploaded on failure\n- Log parsing for test result summary\n- Timeout handling (max 10 minutes per test)\n\n## EXIT CODES\n- 0: All tests passed\n- 1: Test failure(s)\n- 2: Environment setup error\n- 3: Timeout\n\n## PLATFORM-SPECIFIC CONSIDERATIONS\n- Windows: PowerShell equivalent scripts (.ps1)\n- macOS: Handle permission dialogs in CI\n- Linux: X11 vs Wayland detection\n\n## TEST REQUIREMENTS\n- All tests pass on fresh install\n- Logs are parseable (valid JSON per line)\n- No sensitive data in logs (transcripts redacted)\n- Timing data collected for performance regression tracking\n\n## WHY THIS MATTERS\nDetailed, structured logging enables automated analysis, performance tracking, and quick debugging when tests fail. JSON format allows parsing and aggregation across test runs.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:28:09.476935829Z","created_by":"ubuntu","updated_at":"2026-02-04T03:52:13.823756182Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-6pe.7","depends_on_id":"translatorvoiceinputtool-6pe","type":"parent-child","created_at":"2026-02-04T03:28:09.476935829Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.7","depends_on_id":"translatorvoiceinputtool-6pe.1","type":"blocks","created_at":"2026-02-04T03:28:13.692174873Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-6pe.8","title":"Third-party licenses and attribution documentation","description":"Create docs/THIRD_PARTY_NOTICES.md with all redistributed dependency licenses.\n\n## ACCEPTANCE CRITERIA\n- docs/THIRD_PARTY_NOTICES.md created and complete\n- All redistributed dependencies listed\n- License text included for each dependency\n- Source URLs and versions documented\n- Model licenses explicitly called out\n- File included in release artifacts\n\n## CONTENT STRUCTURE\n\\`\\`\\`markdown\n# Third-Party Notices\n\nThis file contains the licenses and notices for third-party software \nincluded in or distributed with OpenVoicy.\n\n## ASR Model\n\n### NVIDIA Parakeet TDT 0.6B v3\n- Source: https://huggingface.co/nvidia/parakeet-tdt-0.6b\n- License: [LICENSE NAME]\n- Copyright: NVIDIA Corporation\n- Notes: [Any redistribution requirements]\n\n## Rust Dependencies\n\n### tauri\n- Version: 2.x.x\n- License: MIT/Apache-2.0\n- Source: https://github.com/tauri-apps/tauri\n\n### [other deps...]\n\n## Python Dependencies\n\n### torch / onnxruntime\n- Version: x.x.x\n- License: BSD-3-Clause / MIT\n- Source: [url]\n\n### sounddevice\n- Version: x.x.x\n- License: MIT\n- Source: [url]\n\n### [other deps...]\n\n## JavaScript Dependencies\n\n### react\n- Version: 18.x.x\n- License: MIT\n- Source: https://github.com/facebook/react\n\n### [other deps...]\n\n## Audio Libraries\n\n### PortAudio\n- Version: 19.x\n- License: MIT\n- Source: http://www.portaudio.com/\n- Notes: Bundled in sidecar binary\n\n## Icons and Assets\n\n### [Any third-party icons]\n- License: [license]\n- Source: [url]\n\\`\\`\\`\n\n## LICENSE COLLECTION PROCESS\n1. Rust: cargo license --json > licenses-rust.json\n2. Python: pip-licenses --format=json > licenses-python.json\n3. Node: license-checker --json > licenses-node.json\n4. Manual: Model and audio library licenses\n5. Compile into single document\n\n## REDISTRIBUTION REQUIREMENTS\nSome licenses require:\n- License text inclusion (MIT, BSD, Apache)\n- Notice preservation\n- Attribution in UI (rare, document if needed)\n\nDocument any special requirements per dependency.\n\n## AUTOMATION\nConsider script to auto-generate from lock files:\n- scripts/generate-notices.sh\n- Runs on release to ensure freshness\n\n## TEST REQUIREMENTS\n- Verify all deps listed (compare to lock files)\n- Verify license text is correct\n- CI check: no GPL/AGPL dependencies (incompatible)\n- Release checklist includes notice verification\n\n## WHY THIS MATTERS\nLicense compliance is a legal requirement. Missing attribution can result in license violations and legal issues.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:28:56.478455034Z","created_by":"ubuntu","updated_at":"2026-02-04T03:29:00.551728278Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-6pe.8","depends_on_id":"translatorvoiceinputtool-1ao.5","type":"blocks","created_at":"2026-02-04T03:29:00.551664139Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.8","depends_on_id":"translatorvoiceinputtool-6pe","type":"parent-child","created_at":"2026-02-04T03:28:56.478455034Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-6pe.9","title":"MVP Definition of Done verification checklist","description":"Final verification checklist that must pass before MVP release.\n\n## PURPOSE\nConsolidate all acceptance criteria into a single pass/fail checklist that validates the MVP is complete and ready for release.\n\n## DEFINITION OF DONE (from PLAN.md)\n- [ ] Fresh install → user configures mic/hotkey → model downloads with visible progress → hold hotkey → speak → release → transcription injected in any app (or clipboard-only with clear reason)\n- [ ] No unhandled panics/crashes during 1-hour manual soak test\n- [ ] Sidecar crash or hang triggers visible error + one-click restart; app remains responsive\n- [ ] Builds produced for Windows/macOS/Linux; sidecar bundled; model downloaded on first run\n- [ ] 'Known limitations' documented for Wayland injection/hotkey constraints and macOS permissions friction\n- [ ] README or docs/KNOWN_LIMITATIONS.md includes 'Supported Platforms & Limitations', referenced from Diagnostics\n- [ ] Self-check exists (tray or UI) that reports: hotkey mode effective, injection mode effective, mic permission, sidecar reachable, model status\n- [ ] Mic test works: input level meter responds on selected device\n\n## PRE-RELEASE VERIFICATION STEPS\n\n### 1. Fresh Install Experience (all platforms)\n- [ ] Delete all app data (config, cache, logs)\n- [ ] Install from packaged artifact\n- [ ] App launches without errors\n- [ ] Tray icon visible\n- [ ] Settings window opens\n- [ ] Model download starts and shows progress\n- [ ] Model download completes successfully\n\n### 2. Core Functionality\n- [ ] Transcription works (record → inject)\n- [ ] Hold mode works on supported platforms\n- [ ] Toggle mode works on all platforms\n- [ ] Focus Guard prevents mis-injection\n- [ ] Clipboard-only fallback works with clear reason\n- [ ] Audio cues play (if enabled)\n- [ ] History shows recent transcripts\n- [ ] Copy last transcript hotkey works\n\n### 3. Error Recovery\n- [ ] Mic disconnect during recording shows error\n- [ ] Sidecar crash triggers auto-restart\n- [ ] Watchdog detects hung sidecar\n- [ ] Network failure during download shows clear error\n- [ ] Disk full shows clear error with space needed\n\n### 4. Offline Mode\n- [ ] With cached model and no network, transcription works\n- [ ] No network calls made during transcription (verify with packet capture or firewall)\n\n### 5. Platform-Specific (Windows)\n- [ ] Works on Windows 10+\n- [ ] Global hotkey works\n- [ ] Text injection works\n- [ ] No antivirus blocks (or documented)\n\n### 6. Platform-Specific (macOS)\n- [ ] Works on macOS 12+\n- [ ] Microphone permission prompt handled\n- [ ] Accessibility permission prompt handled\n- [ ] Gatekeeper/quarantine handled\n\n### 7. Platform-Specific (Linux X11)\n- [ ] Works on major distros (Ubuntu/Fedora)\n- [ ] Global hotkey works\n- [ ] Text injection works\n\n### 8. Platform-Specific (Linux Wayland)\n- [ ] Toggle mode works (hold gracefully degrades)\n- [ ] Clipboard-only works\n- [ ] Clear messaging about limitations\n\n### 9. Documentation Complete\n- [ ] README with quick start\n- [ ] KNOWN_LIMITATIONS.md complete\n- [ ] PRIVACY.md complete\n- [ ] THIRD_PARTY_NOTICES.md complete\n- [ ] MANUAL_CHECKLIST.md usable\n\n### 10. Stability Soak Test\n- [ ] Run app for 1 hour with periodic transcriptions\n- [ ] No memory leaks (memory stays bounded)\n- [ ] No crashes or hangs\n- [ ] Log size stays bounded\n\n## SIGN-OFF\nAll boxes checked → MVP ready for release\nAny unchecked → document as known issue OR fix before release\n\n## WHY THIS MATTERS\nThis checklist ensures nothing is forgotten before release. Every item maps to a user expectation or stability requirement.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:41:41.180769343Z","created_by":"ubuntu","updated_at":"2026-02-04T03:42:41.364215534Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-6pe.9","depends_on_id":"translatorvoiceinputtool-6pe","type":"parent-child","created_at":"2026-02-04T03:41:41.180769343Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-6pe.9","depends_on_id":"translatorvoiceinputtool-6pe.7","type":"blocks","created_at":"2026-02-04T03:42:41.364103406Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-kro","title":"M5: Packaging + CI","description":"MILESTONE M5 (Day 5-7): Reproducible builds for all platforms with bundled sidecar.\n\n## PURPOSE\nCreate production-ready build and packaging pipeline that produces distributable artifacts for Windows, macOS, and Linux. Ensures the sidecar is properly bundled and the app runs without system Python.\n\n## KEY DELIVERABLES\n- Sidecar builds per OS via PyInstaller (CPU-only baseline)\n- Tauri bundling config with sidecar as externalBin/resources\n- CI build matrix with tests for all platforms\n- Schema drift checks and protocol validation in CI\n- Protocol parser fuzz tests\n- \"Offline cached\" integration test mode\n\n## PLATFORM TARGETS\n- Windows x64\n- macOS x64 (Intel) and arm64 (Apple Silicon)\n- Linux x64 (AppImage or .deb)\n\n## CI REQUIREMENTS\n- cargo test (Rust)\n- pytest (Python)\n- Schema drift checks between Rust/TypeScript/Python types\n- IPC_V1_EXAMPLES.jsonl validation\n- Protocol parser fuzzing\n- Offline cached test mode (cache present, network disallowed)\n\n## ARTIFACT REQUIREMENTS\n- CPU-only baseline for each platform\n- Build manifest with versions, git SHA, timestamp\n- GPU support documented as experimental where applicable\n- THIRD_PARTY_NOTICES.md bundled with release\n\n## STARTUP SELF-CHECK\nApp must verify sidecar exists and is executable at startup, with specific remediation for quarantine/permission issues on macOS.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-02-04T03:03:15.186646644Z","created_by":"ubuntu","updated_at":"2026-02-04T03:03:15.186646644Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"translatorvoiceinputtool-kro.1","title":"M5.1: Build sidecar per OS via PyInstaller","description":"Build sidecar as standalone executable for each platform using PyInstaller.\n\n## ACCEPTANCE CRITERIA\n- App runs without system Python dependency\n- Sidecar starts on first launch\n- CPU-only baseline artifact exists for each OS (no GPU required)\n- GPU status documented per artifact (supported/unsupported/experimental)\n- Binary includes all Python dependencies\n- Startup time < 5 seconds on reasonable hardware\n- Binary size documented (target: < 500MB including model-related deps)\n\n## BUILD TARGETS\n\n### Windows (x64)\n- PyInstaller with --onefile or --onedir\n- MSVC runtime bundled\n- No conda/Python installation required\n- Artifact: openvoicy-sidecar.exe or openvoicy-sidecar/ directory\n\n### macOS (x64 and arm64)\n- PyInstaller for each architecture\n- Code signing for Gatekeeper compliance (or document manual approval)\n- Universal binary if feasible, otherwise separate artifacts\n- Artifact: openvoicy-sidecar (Mach-O executable)\n\n### Linux (x64)\n- PyInstaller with appropriate glibc compatibility\n- Consider manylinux-compatible base if using Docker build\n- Bundle libstdc++ if needed for older distros\n- Artifact: openvoicy-sidecar (ELF executable)\n\n## CPU VS GPU VARIANTS\n\n### CPU-only baseline (REQUIRED for MVP)\n- Works on any system without GPU\n- Uses CPU-based inference (ONNX Runtime CPU or similar)\n- Slower but universally compatible\n- This is the PRIMARY artifact for initial release\n\n### GPU-accelerated (OPTIONAL/EXPERIMENTAL for MVP)\n- CUDA support for NVIDIA GPUs\n- May require CUDA runtime bundled or system CUDA\n- Document minimum CUDA version\n- NOT required for MVP; can be post-MVP enhancement\n\n## PYINSTALLER CONFIGURATION\n```python\n# sidecar.spec\na = Analysis(\n    ['src/openvoicy_sidecar/__main__.py'],\n    pathex=[],\n    binaries=[],\n    datas=[\n        # Include any data files needed\n    ],\n    hiddenimports=[\n        'sounddevice',\n        'numpy',\n        'onnxruntime',\n        # ... other imports PyInstaller might miss\n    ],\n    hookspath=[],\n    runtime_hooks=[],\n    excludes=[\n        'matplotlib',\n        'tkinter',\n        # ... exclude unused heavy deps\n    ],\n    win_no_prefer_redirects=False,\n    win_private_assemblies=False,\n    noarchive=False,\n)\npyz = PYZ(a.pure, a.zipped_data)\nexe = EXE(\n    pyz,\n    a.scripts,\n    [],\n    exclude_binaries=True,\n    name='openvoicy-sidecar',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    console=True,  # Required for stdin/stdout IPC\n)\n```\n\n## BUILD SCRIPTS\n- scripts/build-sidecar.sh (Linux/macOS)\n- scripts/build-sidecar.ps1 (Windows)\n\nScript responsibilities:\n1. Create/activate virtual environment\n2. Install dependencies from pyproject.toml\n3. Run PyInstaller\n4. Verify executable starts and responds to system.ping\n5. Calculate and log binary size\n6. Move artifact to dist/\n\n## VERIFICATION STEPS\nAfter build, verify:\n```bash\n# Start sidecar and send ping\necho '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"system.ping\",\"params\":{}}' | ./openvoicy-sidecar\n\n# Expected response:\n# {\"jsonrpc\":\"2.0\",\"id\":1,\"result\":{\"version\":\"0.1.0\",\"protocol\":\"v1\"}}\n```\n\n## SIZE OPTIMIZATION\n- Use --exclude-module for unused modules\n- Use UPX compression where beneficial\n- Consider --onedir for faster startup vs --onefile for simpler distribution\n- Profile imports to find unexpected heavy dependencies\n\n## STARTUP TIME BUDGET\nTarget: < 5 seconds from spawn to responding to system.ping\n- Lazy imports where possible\n- Defer model loading until asr.initialize called\n- Profile and optimize if exceeding target\n\n## ARTIFACT MANIFEST\nEach build produces manifest.json:\n```json\n{\n  \"version\": \"0.1.0\",\n  \"platform\": \"linux-x64\",\n  \"python_version\": \"3.11.x\",\n  \"build_timestamp\": \"2026-02-04T12:00:00Z\",\n  \"git_sha\": \"abc123\",\n  \"binary_size_bytes\": 123456789,\n  \"gpu_support\": \"none\",  // \"none\" | \"cuda\" | \"experimental\"\n  \"onnxruntime_version\": \"1.17.0\"\n}\n```\n\n## TEST REQUIREMENTS\n- Build script succeeds on CI for each platform\n- Built binary starts and responds to system.ping\n- Built binary can enumerate audio devices (audio.list_devices)\n- Built binary can run audio meter (audio.meter_start)\n- Startup time measured and logged\n- Binary size measured and logged\n- No system Python required (test on clean VM/container)\n\n## KNOWN ISSUES TO DOCUMENT\n- macOS: may trigger Gatekeeper on first run\n- Linux: glibc version compatibility\n- Windows: may need VC++ redistributable\n- All: first startup may be slower (unpacking/caching)\n\n## WHY THIS MATTERS\nThe sidecar must run without requiring users to install Python. PyInstaller bundles everything needed, but requires careful configuration to keep size reasonable and ensure all dependencies are included.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:14:30.215142463Z","created_by":"ubuntu","updated_at":"2026-02-04T04:41:56.111410146Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-kro.1","depends_on_id":"translatorvoiceinputtool-13v.8","type":"blocks","created_at":"2026-02-04T03:20:24.452363637Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-kro.1","depends_on_id":"translatorvoiceinputtool-1ao.6","type":"blocks","created_at":"2026-02-04T03:20:24.359018206Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-kro.1","depends_on_id":"translatorvoiceinputtool-kro","type":"parent-child","created_at":"2026-02-04T03:14:30.215142463Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-kro.2","title":"M5.2: Tauri bundling with sidecar","description":"Configure Tauri to bundle sidecar as external binary for all target platforms.\n\n## ACCEPTANCE CRITERIA\n- Sidecar bundled as externalBin resource in Tauri config\n- Startup self-check verifies sidecar exists and is executable\n- macOS quarantine handling with remediation dialog\n- Linux executable permissions verified\n- Windows antivirus false-positive documented\n- Platform bundles: Windows .msi/.exe, macOS .dmg, Linux .AppImage/.deb\n\n## IMPLEMENTATION NOTES\nFile: src-tauri/tauri.conf.json\n\n## EXTERNALBINS CONFIGURATION\n\\`\\`\\`json\n{\n  \"tauri\": {\n    \"bundle\": {\n      \"externalBin\": [\n        \"binaries/openvoicy-sidecar\"\n      ]\n    }\n  }\n}\n\\`\\`\\`\n\nThe sidecar binary name varies by platform:\n- Windows: openvoicy-sidecar-x86_64-pc-windows-msvc.exe\n- macOS Intel: openvoicy-sidecar-x86_64-apple-darwin\n- macOS ARM: openvoicy-sidecar-aarch64-apple-darwin\n- Linux: openvoicy-sidecar-x86_64-unknown-linux-gnu\n\n## STARTUP SELF-CHECK\n\\`\\`\\`rust\nfn verify_sidecar() -> Result<PathBuf, SidecarError> {\n    let path = app_handle.path_resolver()\n        .resolve_resource(\"binaries/openvoicy-sidecar\")\n        .ok_or(SidecarError::NotBundled)?;\n    \n    if !path.exists() {\n        return Err(SidecarError::NotFound(path));\n    }\n    \n    #[cfg(unix)]\n    if !is_executable(&path) {\n        return Err(SidecarError::NotExecutable(path));\n    }\n    \n    Ok(path)\n}\n\\`\\`\\`\n\n## MACOS QUARANTINE HANDLING\nAfter download, macOS marks binaries with quarantine attribute. Handle:\n1. Detect quarantine: xattr -l shows com.apple.quarantine\n2. Show dialog: \"OpenVoicy needs permission to run. Click to allow.\"\n3. Action: Open System Preferences > Security > Allow\n4. Alternative: Run xattr -cr on app bundle (documented for developers)\n\n## LINUX PERMISSIONS\nEnsure executable bit set during bundling:\n\\`\\`\\`bash\nchmod +x binaries/openvoicy-sidecar\n\\`\\`\\`\n\nAppImage and .deb should preserve permissions. Test after install.\n\n## WINDOWS ANTIVIRUS\nPyInstaller executables often trigger false positives:\n- Document known detections\n- Provide VirusTotal link in release notes\n- Consider code signing certificate (post-MVP)\n\n## BUNDLE FORMATS\n\n### Windows\n- .msi installer (recommended)\n- .exe NSIS installer (alternative)\n- Include sidecar in Program Files\n\n### macOS\n- .dmg disk image\n- .app bundle inside\n- Sidecar in Contents/Resources/binaries/\n\n### Linux\n- .AppImage (portable, recommended)\n- .deb package (Debian/Ubuntu)\n- Sidecar in usr/share/openvoicy/binaries/\n\n## BUNDLE SCRIPTS\nFiles:\n- scripts/bundle-sidecar.sh (copies sidecar to Tauri resources)\n- scripts/bundle-sidecar.ps1 (Windows version)\n\n## TEST REQUIREMENTS\n- Verify sidecar launches from bundled location\n- Test quarantine handling on macOS\n- Verify executable permissions on Linux\n- Test installer on fresh systems\n\n## WHY THIS MATTERS\nBundling is critical for seamless user experience. Users should not need to manage sidecar separately.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:17:21.681038779Z","created_by":"ubuntu","updated_at":"2026-02-04T03:27:04.902920663Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-kro.2","depends_on_id":"translatorvoiceinputtool-6pe.1","type":"blocks","created_at":"2026-02-04T03:20:24.657197527Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-kro.2","depends_on_id":"translatorvoiceinputtool-kro","type":"parent-child","created_at":"2026-02-04T03:17:21.681038779Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-kro.2","depends_on_id":"translatorvoiceinputtool-kro.1","type":"blocks","created_at":"2026-02-04T03:20:24.550545865Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-kro.3","title":"M5.3: CI build matrix + tests","description":"Create GitHub Actions CI pipeline for all platforms with comprehensive testing.\n\n## ACCEPTANCE CRITERIA\n- cargo test runs on all platforms\n- pytest runs on all platforms\n- Schema drift checks between Rust/TS/Python\n- IPC_V1_EXAMPLES.jsonl validation\n- Protocol parser fuzz tests\n- Offline cached integration test mode\n- Artifacts include build manifest\n\n## CI JOBS\n\n### Test Jobs (run on every PR)\n1. rust-test: cargo test on ubuntu/windows/macos\n2. python-test: pytest on ubuntu/windows/macos\n3. typescript-test: npm test on ubuntu\n4. schema-drift: validate types match across languages\n5. protocol-validate: parse IPC examples, verify shapes\n\n### Build Jobs (run on merge to main)\n1. build-sidecar-{windows,macos-x64,macos-arm64,linux}\n2. build-app-{windows,macos,linux}\n3. bundle-release\n\n### Fuzz Jobs (scheduled weekly)\n1. fuzz-protocol-rust: cargo fuzz for JSON-RPC parser\n2. fuzz-protocol-python: hypothesis for sidecar parser\n\n### Integration Jobs (run on release)\n1. offline-integration: model cached, network blocked, run E2E\n\n## ARTIFACT MANIFEST\nEach build includes manifest.json:\n- app_version, git_sha, git_branch\n- build_timestamp\n- rust_version, python_version, node_version\n- platform, arch\n- sidecar_hash\n\n## SCHEMA DRIFT DETECTION\nCompare generated types across languages:\n- Rust: serde types\n- TypeScript: interface definitions\n- Python: dataclass/TypedDict\n\nFail if types diverge from shared schema.\n\n## WHY THIS MATTERS\nCI ensures code quality and catches regressions before merge. Build matrix covers all platforms.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:17:39.161958802Z","created_by":"ubuntu","updated_at":"2026-02-04T03:51:41.828588691Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-kro.3","depends_on_id":"translatorvoiceinputtool-13v.9","type":"blocks","created_at":"2026-02-04T03:31:54.415231219Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-kro.3","depends_on_id":"translatorvoiceinputtool-1xu.8","type":"blocks","created_at":"2026-02-04T03:51:41.828503362Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-kro.3","depends_on_id":"translatorvoiceinputtool-kro","type":"parent-child","created_at":"2026-02-04T03:17:39.161958802Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-kro.3","depends_on_id":"translatorvoiceinputtool-kro.1","type":"blocks","created_at":"2026-02-04T03:20:24.767079444Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-kro.3","depends_on_id":"translatorvoiceinputtool-kro.2","type":"blocks","created_at":"2026-02-04T03:20:24.858837920Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-kro.3","depends_on_id":"translatorvoiceinputtool-t89.12","type":"blocks","created_at":"2026-02-04T03:31:54.315926478Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-kro.4","title":"Protocol parser fuzz testing","description":"Implement fuzz testing for JSON-RPC protocol parsers in both Rust and Python.\n\n## ACCEPTANCE CRITERIA\n- Rust protocol parser fuzz tests using cargo-fuzz\n- Python protocol parser fuzz tests using hypothesis\n- Fuzz tests run in CI (weekly scheduled job)\n- No crashes or panics from malformed input\n- Memory safety verified (no buffer overflows)\n\n## RUST FUZZ TESTING\nFile: fuzz/fuzz_targets/protocol_parser.rs\n\nUse cargo-fuzz with libFuzzer:\n\\`\\`\\`rust\n#![no_main]\nuse libfuzzer_sys::fuzz_target;\nuse openvoicy::ipc::parse_message;\n\nfuzz_target!(|data: &[u8]| {\n    // Should never panic, even with malformed input\n    if let Ok(s) = std::str::from_utf8(data) {\n        let _ = parse_message(s);\n    }\n});\n\\`\\`\\`\n\nTest categories:\n- Random bytes\n- Valid JSON with invalid structure\n- Oversized messages (> 1 MiB)\n- Unicode edge cases\n- Nested/recursive structures\n\n## PYTHON FUZZ TESTING\nFile: sidecar/tests/test_protocol_fuzz.py\n\nUse hypothesis library:\n\\`\\`\\`python\nfrom hypothesis import given, strategies as st\nfrom openvoicy_sidecar.protocol import parse_message\n\n@given(st.binary())\ndef test_parse_never_crashes_on_bytes(data):\n    try:\n        parse_message(data.decode('utf-8', errors='replace'))\n    except (ValueError, KeyError, TypeError):\n        pass  # Expected errors for malformed input\n\n@given(st.text(max_size=10000))\ndef test_parse_never_crashes_on_text(data):\n    try:\n        parse_message(data)\n    except (ValueError, KeyError, TypeError):\n        pass\n\n@given(st.recursive(\n    st.none() | st.booleans() | st.integers() | st.text(),\n    lambda children: st.lists(children) | st.dictionaries(st.text(), children)\n))\ndef test_parse_handles_arbitrary_json_structures(data):\n    import json\n    try:\n        parse_message(json.dumps(data))\n    except (ValueError, KeyError, TypeError):\n        pass\n\\`\\`\\`\n\n## CI INTEGRATION\n.github/workflows/fuzz.yml:\n\\`\\`\\`yaml\nname: Fuzz Testing\non:\n  schedule:\n    - cron: '0 0 * * 0'  # Weekly on Sunday\n  workflow_dispatch:\n\njobs:\n  rust-fuzz:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install cargo-fuzz\n        run: cargo install cargo-fuzz\n      - name: Run fuzz tests\n        run: cargo fuzz run protocol_parser -- -max_total_time=600\n\n  python-fuzz:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n      - name: Install dependencies\n        run: pip install hypothesis pytest\n      - name: Run hypothesis tests\n        run: pytest sidecar/tests/test_protocol_fuzz.py -v --hypothesis-seed=0\n\\`\\`\\`\n\n## CORPUS MANAGEMENT\nMaintain interesting test cases:\n- fuzz/corpus/protocol_parser/ for cargo-fuzz\n- Add crash cases to regression tests\n- Seed with IPC_V1_EXAMPLES.jsonl\n\n## TEST REQUIREMENTS\n- 10 minutes of fuzzing produces no crashes\n- Memory usage stays bounded\n- Proper error handling for all malformed inputs\n- Crashes are fixed before release\n\n## WHY THIS MATTERS\nProtocol parsing is a security-critical boundary. Malformed messages from a compromised or buggy sidecar should not crash the app or cause memory corruption.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:28:32.151696852Z","created_by":"ubuntu","updated_at":"2026-02-04T03:28:36.772799451Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-kro.4","depends_on_id":"translatorvoiceinputtool-13v.1","type":"blocks","created_at":"2026-02-04T03:28:36.661661748Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-kro.4","depends_on_id":"translatorvoiceinputtool-kro","type":"parent-child","created_at":"2026-02-04T03:28:32.151696852Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-kro.4","depends_on_id":"translatorvoiceinputtool-t89.2","type":"blocks","created_at":"2026-02-04T03:28:36.772682233Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89","title":"M2: Rust Core MVP","description":"MILESTONE M2 (Day 1-3): Supervise sidecar, orchestrate recording, inject text safely, tray/hotkey, history.\n\n## PURPOSE\nBuild the complete Rust core that orchestrates all desktop-side functionality. This is the \"brain\" of the application - it owns state, supervises the sidecar, handles hotkeys, performs text injection, and manages configuration.\n\n## KEY DELIVERABLES\n- Sidecar lifecycle management with restart/backoff\n- RPC client with correlation, timeouts, notification handling\n- Capability detection (effective hotkey/injection mode per platform)\n- Recording controller with Rust-authoritative session IDs\n- Text injection with Focus Guard (prevents mis-injection after focus change)\n- Transcript history ring buffer\n- Global hotkey handling with audible cues\n- Model orchestration (proactive initialization)\n- Config persistence with migrations\n- Watchdog for hang detection + resume revalidation\n\n## ARCHITECTURE CONTEXT\nState machine: idle → loading_model (optional) → recording → transcribing → idle (or error)\nRust generates session_id (UUID v4) and passes to sidecar. Stale notifications are ignored.\n\n## KEY DESIGN DECISIONS\n- Injection default = clipboard paste (best Unicode reliability)\n- Focus Guard (default ON): capture focus signature at stop-time; if changed by inject-time, clipboard-only + warning\n- Never inject into OpenVoicy itself (settings focused → clipboard-only)\n\n## COORDINATION GATE\n\"record loop + Focus Guard + injection stub mode without UI\" demo must merge before M3.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-02-04T03:02:27.654949932Z","created_by":"ubuntu","updated_at":"2026-02-04T03:02:27.654949932Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"translatorvoiceinputtool-t89.1","title":"M2.1: Sidecar manager with spawn/restart/backoff","description":"Implement sidecar lifecycle management with robust supervision.\n\n## ACCEPTANCE CRITERIA\n- Spawn sidecar executable and capture stdout/stderr\n- Restart on crash with exponential backoff\n- Maximum restart attempts: 5 (configurable)\n- Backoff: 250ms → 500ms → 1s → 2s → 10s (exponential)\n- Crash simulation mode for testing without ML deps\n- User-visible restart action in tray menu\n\n## IMPLEMENTATION NOTES\nFile: src-tauri/src/sidecar.rs\n\nSpawn configuration:\n- stdin: pipe for sending requests\n- stdout: pipe for receiving responses\n- stderr: capture for logging (not IPC)\n- working directory: app cache directory\n\n## LIFECYCLE STATES\n- NotStarted: initial state\n- Starting: spawn in progress\n- Running: process alive, IPC working\n- Restarting: crashed, waiting backoff\n- Failed: max retries exceeded\n\n## RESTART LOGIC\n```rust\nfn on_crash(&mut self) {\n    if self.restart_count >= MAX_RETRIES {\n        self.state = Failed;\n        emit_error(\"Sidecar failed to start after multiple attempts\");\n        return;\n    }\n    let delay = min(10_000, 250 * 2^self.restart_count);\n    self.restart_count += 1;\n    sleep(delay);\n    self.spawn();\n}\n```\n\n## CRASH DETECTION\n- Process exited (waitpid returns)\n- stdout closed unexpectedly\n- stderr shows fatal error pattern\n\n## CRASH SIMULATION MODE\nFor testing: inject crashes via RPC command or file trigger.\nAllows testing restart logic without actual ML crashes.\n\n## ERROR REPORTING\n- Log crash with exit code and last stderr output\n- Emit event to UI: \"Sidecar crashed, restarting...\"\n- After max retries: \"Sidecar failed, click to retry\"\n\n## WHY THIS MATTERS\nThe sidecar can crash due to ML issues, memory problems, etc. Automatic restart with backoff provides resilience without user intervention.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:07:59.909787950Z","created_by":"ubuntu","updated_at":"2026-02-04T03:19:44.737380859Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.1","depends_on_id":"translatorvoiceinputtool-1ao.1","type":"blocks","created_at":"2026-02-04T03:19:44.632708635Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.1","depends_on_id":"translatorvoiceinputtool-1ao.3","type":"blocks","created_at":"2026-02-04T03:19:44.737316549Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.1","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:07:59.909787950Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.10","title":"M2.10: Watchdog + resume revalidation","description":"Implement hang detection and OS suspend/resume handling.\n\n## ACCEPTANCE CRITERIA\n- Watchdog detects non-crash sidecar hangs\n- Triggers restart if ping/status fails for N seconds\n- On OS resume: re-check sidecar reachable\n- On OS resume: re-check device availability\n- On OS resume: re-check model ready\n- Watchdog is testable without ML dependencies\n\n## IMPLEMENTATION NOTES\nFile: src-tauri/src/watchdog.rs\n\n## WATCHDOG LOGIC\n```rust\npub struct Watchdog {\n    last_activity: Instant,\n    hang_threshold: Duration,  // Default 30s\n}\n\nimpl Watchdog {\n    pub fn mark_activity(&mut self) {\n        self.last_activity = Instant::now();\n    }\n    \n    pub async fn check(&self) -> WatchdogResult {\n        // Try ping with short timeout\n        match self.rpc.call(\"system.ping\", json!({})).await {\n            Ok(_) => {\n                self.mark_activity();\n                WatchdogResult::Healthy\n            }\n            Err(e) if self.last_activity.elapsed() > self.hang_threshold => {\n                WatchdogResult::Hung\n            }\n            Err(_) => {\n                WatchdogResult::Unhealthy\n            }\n        }\n    }\n}\n```\n\n## WATCHDOG LOOP\n```rust\nasync fn watchdog_loop(&mut self) {\n    loop {\n        sleep(Duration::from_secs(10)).await;\n        \n        match self.watchdog.check().await {\n            WatchdogResult::Healthy => continue,\n            WatchdogResult::Unhealthy => {\n                log::warn!(\"Sidecar unhealthy, will check again\");\n            }\n            WatchdogResult::Hung => {\n                log::error!(\"Sidecar appears hung, restarting\");\n                self.sidecar.restart().await;\n            }\n        }\n    }\n}\n```\n\n## RESUME REVALIDATION\n```rust\nfn on_system_resume(&mut self) {\n    log::info!(\"System resumed from suspend\");\n    \n    // Re-validate sidecar\n    match self.rpc.call(\"system.ping\", json!({})).await {\n        Ok(_) => log::info!(\"Sidecar responsive after resume\"),\n        Err(_) => {\n            log::warn!(\"Sidecar unresponsive after resume, restarting\");\n            self.sidecar.restart().await;\n        }\n    }\n    \n    // Re-check device\n    self.refresh_devices().await;\n    \n    // Re-check model\n    self.refresh_model_status().await;\n}\n```\n\n## PLATFORM-SPECIFIC RESUME DETECTION\n- Windows: WM_POWERBROADCAST / PBT_APMRESUMEAUTOMATIC\n- macOS: NSWorkspace willSleepNotification / didWakeNotification\n- Linux: systemd-logind PrepareForSleep signal via D-Bus\n\n## TESTING\n- Inject artificial delays in sidecar to simulate hang\n- Mock resume events in tests\n- Verify restart count and backoff still apply\n\n## WHY THIS MATTERS\nA hung sidecar is worse than a crashed one - user sees no errors but nothing works. Watchdog catches this case.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:10:53.363482561Z","created_by":"ubuntu","updated_at":"2026-02-04T03:19:54.831280553Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.10","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:10:53.363482561Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.10","depends_on_id":"translatorvoiceinputtool-t89.1","type":"blocks","created_at":"2026-02-04T03:19:54.743712742Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.10","depends_on_id":"translatorvoiceinputtool-t89.2","type":"blocks","created_at":"2026-02-04T03:19:54.831214280Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.11","title":"Tray menu implementation","description":"$(cat <<'EOF'\nImplement system tray icon with context menu for core app interaction.\n\n## ACCEPTANCE CRITERIA\n- Tray icon visible on all platforms\n- Context menu with all items working\n- Icon changes based on app state\n- Menu items enable/disable based on state\n- Tooltip shows current status\n\n## MENU ITEMS\n1. **OpenVoicy** (header, non-clickable)\n2. **Show Settings** - Opens settings window\n3. ---separator---\n4. **Status: Ready** / **Recording...** / **Transcribing...** (dynamic, non-clickable)\n5. **Enable/Disable** - Toggle transcription on/off (when disabled, hotkey presses are ignored but app stays running)\n6. ---separator---\n7. **Copy Last Transcript** - Copies most recent transcript (grayed if none)\n8. **Restart Sidecar** - Force restart of background service\n9. ---separator---\n10. **Quit** - Exit application\n\n## ENABLE/DISABLE TOGGLE BEHAVIOR\nWhen **disabled**:\n- Tray icon changes to a \"paused\" or \"disabled\" variant (e.g., grayed out)\n- Hotkey presses are completely ignored (no recording starts)\n- Sidecar remains running (no restart needed to re-enable)\n- State is NOT persisted (re-enabled on app restart)\n- Menu item shows \"Enable\" when currently disabled\n- UI status shows \"Paused\" or similar\n\nWhen **enabled** (default):\n- Normal operation\n- Menu item shows \"Disable\"\n\nThis feature allows users to temporarily pause transcription without quitting the app (useful during meetings, presentations, etc.).\n\n## TRAY ICONS (6 states - adding disabled state)\n- tray-idle.png: Default, app ready (green checkmark or neutral icon)\n- tray-recording.png: Recording in progress (red dot, optionally animated)\n- tray-transcribing.png: Processing transcription (yellow/orange processing)\n- tray-loading.png: Model downloading/loading (blue, progress indicator)\n- tray-error.png: Error state (red exclamation mark)\n- tray-disabled.png: App disabled/paused (grayed out or pause icon)\n\nIcons should be:\n- 16x16, 22x22, and 32x32 for different DPIs\n- PNG format with transparency\n- High contrast for both light and dark system themes\n\n## PLATFORM NOTES\n\n### Windows\n- Use tauri-plugin-system-tray\n- SystemTray via winrt/shell32\n- Icons in .ico format also needed\n\n### macOS\n- NSStatusItem\n- Template images for dark/light mode\n- May need @2x versions for Retina\n\n### Linux\n- StatusNotifierItem (preferred) or libappindicator\n- Some desktop environments have limited support\n- Test on GNOME, KDE, and common DEs\n\n## IMPLEMENTATION\nFile: src-tauri/src/tray.rs\n\n```rust\nuse tauri::{\n    CustomMenuItem, SystemTray, SystemTrayMenu, \n    SystemTrayMenuItem, SystemTrayEvent\n};\n\npub fn create_tray() -> SystemTray {\n    let menu = SystemTrayMenu::new()\n        .add_item(CustomMenuItem::new(\"show\", \"Show Settings\"))\n        .add_native_item(SystemTrayMenuItem::Separator)\n        .add_item(CustomMenuItem::new(\"status\", \"Status: Ready\").disabled())\n        .add_item(CustomMenuItem::new(\"toggle\", \"Disable\"))\n        .add_native_item(SystemTrayMenuItem::Separator)\n        .add_item(CustomMenuItem::new(\"copy_last\", \"Copy Last Transcript\"))\n        .add_item(CustomMenuItem::new(\"restart\", \"Restart Sidecar\"))\n        .add_native_item(SystemTrayMenuItem::Separator)\n        .add_item(CustomMenuItem::new(\"quit\", \"Quit\"));\n    \n    SystemTray::new().with_menu(menu)\n}\n\npub fn update_tray_state(app: &AppHandle, state: AppState, enabled: bool) {\n    let icon = if !enabled {\n        include_bytes!(\"../icons/tray-disabled.png\")\n    } else {\n        match state {\n            AppState::Idle => include_bytes!(\"../icons/tray-idle.png\"),\n            AppState::Recording => include_bytes!(\"../icons/tray-recording.png\"),\n            AppState::Transcribing => include_bytes!(\"../icons/tray-transcribing.png\"),\n            AppState::LoadingModel => include_bytes!(\"../icons/tray-loading.png\"),\n            AppState::Error => include_bytes!(\"../icons/tray-error.png\"),\n        }\n    };\n    app.tray_handle().set_icon(Icon::Raw(icon.to_vec())).unwrap();\n    \n    let status_text = if !enabled {\n        \"Status: Paused\"\n    } else {\n        match state {\n            AppState::Idle => \"Status: Ready\",\n            AppState::Recording => \"Status: Recording...\",\n            AppState::Transcribing => \"Status: Transcribing...\",\n            AppState::LoadingModel => \"Status: Loading model...\",\n            AppState::Error => \"Status: Error\",\n        }\n    };\n    app.tray_handle().get_item(\"status\").set_title(status_text).unwrap();\n    \n    // Update toggle menu item\n    let toggle_text = if enabled { \"Disable\" } else { \"Enable\" };\n    app.tray_handle().get_item(\"toggle\").set_title(toggle_text).unwrap();\n}\n```\n\n## TEST REQUIREMENTS\n- Verify tray appears on Windows/macOS/Linux\n- Verify all menu items respond to clicks\n- Verify icon changes with state transitions\n- Verify \"Copy Last Transcript\" works\n- Verify Enable/Disable toggle works (hotkey ignored when disabled)\n- Test on systems without tray support (graceful degradation)\n\n## WHY THIS MATTERS\nThe tray provides quick access to app functionality without opening the full UI. It is the primary interface for users who want minimal visual footprint. The Enable/Disable toggle is essential for users who want to temporarily pause without quitting.\nEOF\n)","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:18:10.236457869Z","created_by":"ubuntu","updated_at":"2026-02-04T03:50:38.287722495Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.11","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:18:10.236457869Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.11","depends_on_id":"translatorvoiceinputtool-t89.14","type":"blocks","created_at":"2026-02-04T03:50:38.287618461Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.11","depends_on_id":"translatorvoiceinputtool-t89.6","type":"blocks","created_at":"2026-02-04T03:20:37.491804196Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.11","depends_on_id":"translatorvoiceinputtool-t89.7","type":"blocks","created_at":"2026-02-04T03:20:37.594229217Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.12","title":"Rust unit tests for core modules","description":"Implement comprehensive Rust unit tests for all core modules.\n\n## ACCEPTANCE CRITERIA\n- All core modules have unit tests\n- Tests are mockable (no ML/sidecar dependency)\n- State machine coverage >= 90%\n- RPC protocol edge cases covered\n- Config migration tests included\n- Focus Guard logic tested\n- History ring buffer tested\n- Tests run in CI on every PR\n\n## MODULES TO TEST\n\n### state.rs (AppState state machine)\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_valid_transitions() {\n        let manager = AppStateManager::new();\n        \n        // idle -> recording\n        assert!(manager.transition(AppState::Recording).is_ok());\n        assert_eq!(manager.get(), AppState::Recording);\n        \n        // recording -> transcribing\n        assert!(manager.transition(AppState::Transcribing).is_ok());\n        assert_eq!(manager.get(), AppState::Transcribing);\n        \n        // transcribing -> idle\n        assert!(manager.transition(AppState::Idle).is_ok());\n        assert_eq!(manager.get(), AppState::Idle);\n    }\n    \n    #[test]\n    fn test_invalid_transitions() {\n        let manager = AppStateManager::new();\n        \n        // idle -> transcribing (invalid, must go through recording)\n        assert!(manager.transition(AppState::Transcribing).is_err());\n    }\n    \n    #[test]\n    fn test_enabled_disabled() {\n        let manager = AppStateManager::new();\n        assert!(manager.is_enabled());\n        \n        manager.set_enabled(false);\n        assert!(!manager.is_enabled());\n        \n        // State unchanged\n        assert_eq!(manager.get(), AppState::Idle);\n    }\n    \n    #[test]\n    fn test_can_start_recording() {\n        let manager = AppStateManager::new();\n        \n        // Should succeed when idle and enabled\n        assert!(manager.can_start_recording().is_ok());\n        \n        // Should fail when disabled\n        manager.set_enabled(false);\n        assert!(matches!(\n            manager.can_start_recording(),\n            Err(CannotRecordReason::Paused)\n        ));\n    }\n    \n    #[test]\n    fn test_error_detail() {\n        let manager = AppStateManager::new();\n        \n        manager.transition_to_error(\"Test error\".to_string());\n        assert_eq!(manager.get(), AppState::Error);\n        \n        // Transition to idle should clear error\n        manager.transition(AppState::Idle).unwrap();\n        // Error detail is cleared\n    }\n}\n```\n\n### ipc/mod.rs (RPC client)\n- Request/response correlation\n- Timeout handling\n- Notification dispatch\n- Partial line buffering\n- Oversized line rejection (>1 MiB)\n- JSON parse error handling\n\n### sidecar.rs (Sidecar manager)\n- Spawn process mock\n- Restart backoff timing\n- Max retry enforcement\n- Crash detection\n- EOF handling\n\n### recording.rs (Recording controller)\n- Session ID generation and correlation\n- State transitions (start/stop/cancel)\n- Too-short recording detection\n- Max duration enforcement\n- Stale notification rejection\n- Transcription timeout\n\n### capabilities.rs (Capability detection)\n- Environment variable mocking for Wayland detection\n- Effective mode computation\n- Reason string generation\n\n### config.rs (Config persistence)\n- Load/save roundtrip\n- Atomic write behavior\n- Migration from old schema versions\n- Corruption fallback to defaults\n- Device UID persistence (not numeric index)\n\n### history.rs (Transcript history)\n- Ring buffer FIFO behavior\n- Max size enforcement\n- Copy last transcript\n- Empty history handling\n\n### focus.rs (Focus Guard)\n- Focus signature capture mock\n- Signature comparison\n- Self-injection prevention\n\n### watchdog.rs (Watchdog)\n- Hang detection timing\n- Resume revalidation trigger\n\n## MOCK STRATEGIES\n\n### Mock Sidecar\n```rust\nstruct MockSidecar {\n    responses: VecDeque<String>,\n}\n\nimpl MockSidecar {\n    fn add_response(&mut self, response: &str) {\n        self.responses.push_back(response.to_string());\n    }\n}\n```\n\n### Mock Focus\n```rust\nstruct MockFocusCapture {\n    signature: Option<FocusSignature>,\n}\n```\n\n### Mock Time\n```rust\nuse tokio::time::pause;  // For timeout testing\n```\n\n## CI REQUIREMENTS\n- cargo test runs all tests\n- Tests must pass before merge\n- Coverage report generated (optional: tarpaulin)\n- No tests depend on ML model or actual sidecar\n\n## FILE STRUCTURE\nEach module has inline #[cfg(test)] mod tests or separate file:\n- src/state.rs (inline tests)\n- src/ipc/tests.rs\n- src/sidecar.rs (inline tests)\n- src/recording.rs (inline tests)\n- src/capabilities.rs (inline tests)\n- src/config.rs (inline tests)\n- src/history.rs (inline tests)\n- src/focus.rs (inline tests)\n- src/watchdog.rs (inline tests)\n\n## INTEGRATION TESTS\nSeparate tests/ directory for cross-module integration:\n- tests/recording_flow.rs - full recording flow with mocked sidecar\n- tests/config_migration.rs - config upgrade scenarios\n\n## TEST REQUIREMENTS\n- All tests pass without network\n- All tests pass without actual sidecar\n- No flaky tests (deterministic)\n- Tests complete in < 30 seconds total\n\n## WHY THIS MATTERS\nUnit tests catch bugs early and enable confident refactoring. Mocking ML/sidecar dependencies ensures tests are fast and reliable in CI.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-04T03:19:01.728509678Z","created_by":"ubuntu","updated_at":"2026-02-04T03:52:59.678217380Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.12","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:19:01.728509678Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.12","depends_on_id":"translatorvoiceinputtool-t89.14","type":"blocks","created_at":"2026-02-04T03:52:59.678104399Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.12","depends_on_id":"translatorvoiceinputtool-t89.2","type":"blocks","created_at":"2026-02-04T03:30:30.895463840Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.12","depends_on_id":"translatorvoiceinputtool-t89.3","type":"blocks","created_at":"2026-02-04T03:30:30.653326779Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.12","depends_on_id":"translatorvoiceinputtool-t89.6","type":"blocks","created_at":"2026-02-04T03:30:30.772901624Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.12","depends_on_id":"translatorvoiceinputtool-t89.9","type":"blocks","created_at":"2026-02-04T03:20:37.370853704Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.13","title":"Create tray icon assets and audio cue sound files","description":"Create all visual and audio assets required for the application.\n\n## ACCEPTANCE CRITERIA\n- 6 tray icon states created for all platforms (including disabled/paused state)\n- Icons work on light and dark system themes\n- Audio cue files created (start, stop, error)\n- All assets bundled in src-tauri/icons/ and src-tauri/sounds/\n- Assets meet platform-specific requirements\n\n## TRAY ICONS (6 STATES)\nEach icon needed at multiple sizes for different DPIs:\n\n| State | Filename | Description | Color/Style |\n|-------|----------|-------------|-------------|\n| Idle | tray-idle.png | Ready, app working | Green checkmark or neutral |\n| Recording | tray-recording.png | Recording in progress | Red dot |\n| Transcribing | tray-transcribing.png | Processing transcription | Yellow/orange processing |\n| Loading | tray-loading.png | Model downloading/loading | Blue progress |\n| Error | tray-error.png | Error state | Red exclamation mark |\n| Disabled | tray-disabled.png | App paused (hotkey ignored) | Grayed out or pause icon |\n\n### Size Requirements\n- 16x16 (standard)\n- 22x22 (some Linux DEs)\n- 32x32 (high DPI)\n- Windows: also .ico format\n- macOS: @2x versions for Retina, template images for dark/light\n\n## AUDIO CUE SOUNDS\n| Sound | Filename | Description | Duration |\n|-------|----------|-------------|----------|\n| Start | cue-start.wav | Recording started | ~100ms short beep/click |\n| Stop | cue-stop.wav | Recording stopped | ~100ms different tone |\n| Error | cue-error.wav | Error occurred | ~200ms warning tone |\n\n### Audio Requirements\n- Format: WAV (PCM, 16-bit, 44.1kHz) for maximum compatibility\n- Short duration (no longer than 200ms)\n- Distinct from each other\n- Not annoying when heard repeatedly\n\n## FILE STRUCTURE\nsrc-tauri/icons/ for all icon files\nsrc-tauri/sounds/ for all audio cue files\n\nIcons:\n- tray-idle.png, tray-idle@2x.png\n- tray-recording.png, tray-recording@2x.png  \n- tray-transcribing.png, tray-transcribing@2x.png\n- tray-loading.png, tray-loading@2x.png\n- tray-error.png, tray-error@2x.png\n- tray-disabled.png, tray-disabled@2x.png\n- icon.ico (Windows app icon)\n- icon.icns (macOS app icon)\n- icon.png (Linux app icon)\n\nSounds:\n- cue-start.wav\n- cue-stop.wav\n- cue-error.wav\n\n## ICON DESIGN GUIDELINES\n- Simple, recognizable silhouettes\n- Work at small sizes (16x16)\n- Distinct states at a glance\n- Consistent visual language\n- Consider colorblind users (do not rely solely on color)\n\n## LICENSING\nCreate original assets OR use permissively licensed sources:\n- Option A: Create simple vector icons in SVG, export to PNG\n- Option B: Use open-licensed icon sets (e.g., Heroicons, Lucide)\nDocument source/license in docs/THIRD_PARTY_NOTICES.md\n\n## TEST REQUIREMENTS\n- Verify all icons display correctly on all platforms\n- Verify icons are distinguishable on light and dark themes\n- Verify audio cues are audible but not jarring\n- Verify sounds play correctly on all platforms\n\n## WHY THIS MATTERS\nVisual and audio feedback is critical for user confidence. Users need to know the app state at a glance. The disabled state is essential for the pause/resume functionality.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:41:15.617832062Z","created_by":"ubuntu","updated_at":"2026-02-04T03:50:05.657115383Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.13","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:41:15.617832062Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.14","title":"M2.0: AppState state machine implementation","description":"Implement the central AppState state machine and state management.\n\n## ACCEPTANCE CRITERIA\n- Single source of truth for application state\n- Thread-safe state transitions\n- State change events emitted to UI\n- Invalid transitions prevented\n- Enabled/disabled (paused) mode support\n- Clear state definitions with allowed transitions\n\n## STATE DEFINITIONS\n```rust\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum AppState {\n    Idle,           // Ready to record\n    LoadingModel,   // Model downloading or initializing\n    Recording,      // Actively recording audio\n    Transcribing,   // Processing transcription\n    Error,          // Error state (recoverable)\n}\n\npub struct AppStateManager {\n    state: RwLock<AppState>,\n    enabled: AtomicBool,  // Whether hotkey is active (false = paused)\n    error_detail: RwLock<Option<String>>,\n    event_sender: broadcast::Sender<StateEvent>,\n}\n\n#[derive(Clone, Debug)]\npub struct StateEvent {\n    pub state: AppState,\n    pub enabled: bool,\n    pub detail: Option<String>,\n    pub timestamp: DateTime<Utc>,\n}\n```\n\n## STATE TRANSITION RULES\nValid transitions (enforced programmatically):\n\nFrom IDLE:\n- → LoadingModel (model init triggered)\n- → Recording (hotkey pressed AND model ready AND enabled)\n- → Error (unexpected failure)\n\nFrom LoadingModel:\n- → Idle (model ready)\n- → Error (model load failed)\n\nFrom Recording:\n- → Transcribing (recording stopped, transcription started)\n- → Idle (recording cancelled, too short, or model not ready)\n- → Error (mic disconnected, sidecar crash)\n\nFrom Transcribing:\n- → Idle (transcription complete, text injected)\n- → Error (transcription failed, timeout)\n\nFrom Error:\n- → Idle (error cleared, retry succeeded)\n- → LoadingModel (retry model init)\n\nANY state:\n- enabled = false pauses hotkey listening (does NOT change state)\n\n## IMPLEMENTATION\nFile: src-tauri/src/state.rs\n\n```rust\nimpl AppStateManager {\n    pub fn new() -> Self {\n        let (tx, _) = broadcast::channel(16);\n        Self {\n            state: RwLock::new(AppState::Idle),\n            enabled: AtomicBool::new(true),\n            error_detail: RwLock::new(None),\n            event_sender: tx,\n        }\n    }\n    \n    pub fn get(&self) -> AppState {\n        *self.state.read().unwrap()\n    }\n    \n    pub fn is_enabled(&self) -> bool {\n        self.enabled.load(Ordering::SeqCst)\n    }\n    \n    pub fn set_enabled(&self, enabled: bool) {\n        self.enabled.store(enabled, Ordering::SeqCst);\n        self.emit_event();\n    }\n    \n    pub fn transition(&self, new_state: AppState) -> Result<(), InvalidTransition> {\n        let mut state = self.state.write().unwrap();\n        let current = *state;\n        \n        if !Self::is_valid_transition(current, new_state) {\n            return Err(InvalidTransition { from: current, to: new_state });\n        }\n        \n        *state = new_state;\n        if new_state != AppState::Error {\n            *self.error_detail.write().unwrap() = None;\n        }\n        \n        drop(state);\n        self.emit_event();\n        Ok(())\n    }\n    \n    pub fn transition_to_error(&self, detail: String) {\n        let mut state = self.state.write().unwrap();\n        *state = AppState::Error;\n        *self.error_detail.write().unwrap() = Some(detail.clone());\n        drop(state);\n        self.emit_event();\n    }\n    \n    pub fn subscribe(&self) -> broadcast::Receiver<StateEvent> {\n        self.event_sender.subscribe()\n    }\n    \n    fn is_valid_transition(from: AppState, to: AppState) -> bool {\n        use AppState::*;\n        matches!(\n            (from, to),\n            (Idle, LoadingModel) |\n            (Idle, Recording) |\n            (Idle, Error) |\n            (LoadingModel, Idle) |\n            (LoadingModel, Error) |\n            (Recording, Transcribing) |\n            (Recording, Idle) |\n            (Recording, Error) |\n            (Transcribing, Idle) |\n            (Transcribing, Error) |\n            (Error, Idle) |\n            (Error, LoadingModel)\n        )\n    }\n    \n    fn emit_event(&self) {\n        let event = StateEvent {\n            state: self.get(),\n            enabled: self.is_enabled(),\n            detail: self.error_detail.read().unwrap().clone(),\n            timestamp: Utc::now(),\n        };\n        let _ = self.event_sender.send(event);\n    }\n}\n```\n\n## INTEGRATION POINTS\n- **Tray**: Subscribes to state events, updates icon and status text\n- **UI**: Subscribes to state events via Tauri event system\n- **Hotkey handler**: Checks enabled flag and state before starting recording\n- **Recording controller**: Calls transition methods\n- **Model orchestrator**: Calls transition methods\n\n## CAN_RECORD CHECK\n```rust\nimpl AppStateManager {\n    pub fn can_start_recording(&self) -> Result<(), CannotRecordReason> {\n        if !self.is_enabled() {\n            return Err(CannotRecordReason::Paused);\n        }\n        match self.get() {\n            AppState::Idle => Ok(()),\n            AppState::LoadingModel => Err(CannotRecordReason::ModelLoading),\n            AppState::Recording => Err(CannotRecordReason::AlreadyRecording),\n            AppState::Transcribing => Err(CannotRecordReason::StillTranscribing),\n            AppState::Error => Err(CannotRecordReason::InErrorState),\n        }\n    }\n}\n```\n\n## TEST REQUIREMENTS\n- Test all valid state transitions succeed\n- Test all invalid state transitions fail\n- Test enabled/disabled toggle\n- Test event emission on state change\n- Test thread safety with concurrent access\n- Test error detail persistence and clearing\n\n## WHY THIS MATTERS\nThe state machine is the heart of the application. It ensures predictable behavior and prevents invalid states (like starting a new recording while already recording). The enabled/disabled flag provides the pause functionality without complex state changes.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:50:31.831678214Z","created_by":"ubuntu","updated_at":"2026-02-04T03:50:31.831678214Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.14","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:50:31.831678214Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.15","title":"Tauri commands interface (UI↔Rust API)","description":"Document and implement the complete set of Tauri commands exposed to the UI.\n\n## PURPOSE\nThis bead documents the complete API surface between the React UI and Rust backend via Tauri commands. This is the contract that UI developers code against.\n\n## ACCEPTANCE CRITERIA\n- All commands documented with types\n- Commands exposed via tauri::command macro\n- Error types consistent across commands\n- UI TypeScript types match Rust types\n- Commands testable without full app startup\n\n## COMPLETE COMMAND LIST\n\n### State Commands\n```rust\n#[tauri::command]\npub fn get_app_state() -> AppStateInfo;\n\n#[tauri::command]\npub fn get_capabilities() -> Capabilities;\n\n#[tauri::command]\npub fn run_self_check() -> SelfCheckResult;\n```\n\n### Config Commands\n```rust\n#[tauri::command]\npub fn get_config() -> AppConfig;\n\n#[tauri::command]\npub fn update_config(config: AppConfig) -> Result<(), ConfigError>;\n\n#[tauri::command]\npub fn reset_config_to_defaults() -> AppConfig;\n```\n\n### Audio Commands\n```rust\n#[tauri::command]\npub async fn list_audio_devices() -> Result<Vec<AudioDevice>, AudioError>;\n\n#[tauri::command]\npub async fn set_audio_device(device_uid: Option<String>) -> Result<String, AudioError>;\n\n#[tauri::command]\npub async fn start_mic_test() -> Result<(), AudioError>;\n\n#[tauri::command]\npub async fn stop_mic_test() -> Result<(), AudioError>;\n```\n\n### Model Commands\n```rust\n#[tauri::command]\npub async fn get_model_status() -> ModelStatus;\n\n#[tauri::command]\npub async fn download_model() -> Result<(), ModelError>;\n\n#[tauri::command]\npub async fn purge_model_cache() -> Result<(), ModelError>;\n```\n\n### History Commands\n```rust\n#[tauri::command]\npub fn get_transcript_history() -> Vec<TranscriptEntry>;\n\n#[tauri::command]\npub fn copy_transcript(id: String) -> Result<(), ClipboardError>;\n\n#[tauri::command]\npub fn copy_last_transcript() -> Result<Option<String>, ClipboardError>;\n\n#[tauri::command]\npub fn clear_history();\n```\n\n### Hotkey Commands\n```rust\n#[tauri::command]\npub fn get_hotkey_status() -> HotkeyStatus;\n\n#[tauri::command]\npub fn set_hotkey(primary: String, copy_last: String) -> Result<(), HotkeyError>;\n```\n\n### Replacement Commands\n```rust\n#[tauri::command]\npub fn get_replacement_rules() -> Vec<ReplacementRule>;\n\n#[tauri::command]\npub async fn set_replacement_rules(rules: Vec<ReplacementRule>) -> Result<(), ReplacementError>;\n\n#[tauri::command]\npub fn preview_replacement(input: String, rules: Vec<ReplacementRule>) -> String;\n\n#[tauri::command]\npub fn get_available_presets() -> Vec<PresetInfo>;\n\n#[tauri::command]\npub fn load_preset(preset_id: String) -> Vec<ReplacementRule>;\n```\n\n### Control Commands\n```rust\n#[tauri::command]\npub fn toggle_enabled() -> bool;  // Returns new enabled state\n\n#[tauri::command]\npub fn is_enabled() -> bool;\n\n#[tauri::command]\npub async fn restart_sidecar() -> Result<(), SidecarError>;\n```\n\n### Diagnostics Commands\n```rust\n#[tauri::command]\npub fn generate_diagnostics() -> DiagnosticsReport;\n\n#[tauri::command]\npub fn get_recent_logs(count: usize) -> Vec<LogEntry>;\n```\n\n## TYPE DEFINITIONS\n\n### AppStateInfo\n```rust\npub struct AppStateInfo {\n    pub state: AppState,\n    pub enabled: bool,\n    pub error_detail: Option<String>,\n}\n```\n\n### Capabilities\n```rust\npub struct Capabilities {\n    pub hotkey_mode: EffectiveMode,\n    pub injection_mode: EffectiveMode,\n    pub permissions: PermissionStatus,\n    pub platform: String,\n}\n\npub struct EffectiveMode {\n    pub configured: String,\n    pub effective: String,\n    pub reason: Option<String>,\n}\n\npub struct PermissionStatus {\n    pub microphone: PermissionState,\n    pub accessibility: Option<PermissionState>,  // macOS only\n}\n```\n\n### SelfCheckResult\n```rust\npub struct SelfCheckResult {\n    pub hotkey: CheckItem,\n    pub injection: CheckItem,\n    pub microphone: CheckItem,\n    pub sidecar: CheckItem,\n    pub model: CheckItem,\n}\n\npub struct CheckItem {\n    pub status: CheckStatus,  // Ok, Warning, Error\n    pub message: String,\n    pub detail: Option<String>,\n}\n```\n\n### AudioDevice\n```rust\npub struct AudioDevice {\n    pub uid: String,\n    pub name: String,\n    pub is_default: bool,\n    pub sample_rate: u32,\n    pub channels: u32,\n}\n```\n\n### ModelStatus\n```rust\npub struct ModelStatus {\n    pub model_id: String,\n    pub status: ModelState,  // Missing, Downloading, Verifying, Ready, Error\n    pub progress: Option<Progress>,\n    pub error: Option<String>,\n}\n\npub struct Progress {\n    pub current: u64,\n    pub total: Option<u64>,\n    pub unit: String,  // \"bytes\" or \"files\"\n}\n```\n\n### TranscriptEntry\n```rust\npub struct TranscriptEntry {\n    pub id: String,\n    pub text: String,\n    pub timestamp: String,  // ISO8601\n    pub audio_duration_ms: u32,\n    pub transcription_duration_ms: u32,\n    pub injection_result: InjectionResult,\n}\n\npub enum InjectionResult {\n    Injected,\n    ClipboardOnly { reason: String },\n    Error { message: String },\n}\n```\n\n## EVENTS (Rust → UI)\n\nEvents emitted to UI via Tauri event system:\n\n```rust\n// State changed\napp.emit_all(\"state_changed\", StateEvent { ... })?;\n\n// Audio level during mic test\napp.emit_all(\"audio_level\", AudioLevelEvent { rms, peak })?;\n\n// Model download progress\napp.emit_all(\"model_progress\", ProgressEvent { ... })?;\n\n// Transcript completed\napp.emit_all(\"transcript_complete\", TranscriptEvent { ... })?;\n\n// Error occurred\napp.emit_all(\"error\", ErrorEvent { ... })?;\n```\n\n## TYPESCRIPT TYPES\nGenerate matching TypeScript types in src/types.ts:\n\n```typescript\ninterface AppStateInfo {\n  state: 'idle' | 'loading_model' | 'recording' | 'transcribing' | 'error';\n  enabled: boolean;\n  errorDetail?: string;\n}\n\ninterface AudioDevice {\n  uid: string;\n  name: string;\n  isDefault: boolean;\n  sampleRate: number;\n  channels: number;\n}\n\n// ... etc\n```\n\n## IMPLEMENTATION FILE\nFile: src-tauri/src/commands.rs\n\nCommands are registered in main.rs:\n```rust\n.invoke_handler(tauri::generate_handler![\n    get_app_state,\n    get_capabilities,\n    get_config,\n    update_config,\n    // ... all commands\n])\n```\n\n## TEST REQUIREMENTS\n- Unit test: each command with mocked dependencies\n- Unit test: error conversion to CommandError\n- Type generation test: TS types match Rust types\n- Integration test: full command roundtrip\n\n## WHY THIS MATTERS\nThis is the complete API that UI developers code against. Clear documentation prevents mismatches and enables parallel development of UI and Rust.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T04:43:02.199493359Z","created_by":"ubuntu","updated_at":"2026-02-04T04:43:11.843142974Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.15","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T04:43:02.199493359Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.15","depends_on_id":"translatorvoiceinputtool-t89.3","type":"blocks","created_at":"2026-02-04T04:43:11.842956146Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.15","depends_on_id":"translatorvoiceinputtool-t89.6","type":"blocks","created_at":"2026-02-04T04:43:11.694954033Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.15","depends_on_id":"translatorvoiceinputtool-t89.9","type":"blocks","created_at":"2026-02-04T04:43:07.543613913Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.2","title":"M2.2: RPC client with correlation, timeouts, notifications","description":"Implement the JSON-RPC 2.0 client for Rust-to-sidecar communication.\n\n## ACCEPTANCE CRITERIA\n- Request/response correlation by id\n- Per-method timeout configuration\n- Notification handling (no id, no response expected)\n- Tolerates partial lines (buffer until newline)\n- Oversized lines (>1 MiB) → fatal error state\n- Centralized timeout configuration\n\n## IMPLEMENTATION NOTES\nFiles:\n- src-tauri/src/ipc/mod.rs (RpcClient)\n- src-tauri/src/ipc/types.rs (message types)\n\n## RPC CLIENT STRUCTURE\n```rust\npub struct RpcClient {\n    sender: mpsc::Sender<String>,\n    pending: HashMap<RequestId, oneshot::Sender<Response>>,\n    next_id: AtomicU64,\n}\n\nimpl RpcClient {\n    pub async fn call<T>(&self, method: &str, params: Value) -> Result<T, RpcError>;\n    pub fn send_notification(&self, method: &str, params: Value);\n}\n```\n\n## READ LOOP\n- Run in separate task\n- Read lines from stdout\n- Parse JSON\n- If has id: correlate with pending request\n- If no id: dispatch as notification\n- Handle parse errors gracefully\n\n## TIMEOUT CONFIGURATION\n```rust\nconst TIMEOUTS: phf::Map<&str, Duration> = phf_map! {\n    \"system.ping\" => Duration::from_secs(1),\n    \"system.info\" => Duration::from_secs(2),\n    \"audio.list_devices\" => Duration::from_secs(2),\n    \"asr.initialize\" => Duration::from_secs(1200), // 20 minutes\n    // ... etc\n};\n```\n\n## ERROR HANDLING\n- Timeout → RpcError::Timeout\n- Parse error → RpcError::Protocol\n- Sidecar error response → RpcError::Remote { code, message, kind }\n- Connection closed → RpcError::Disconnected\n\n## NOTIFICATION DISPATCH\n- Use tokio broadcast channel\n- Subscribers filter by method name\n- Main app subscribes for state/transcription events\n\n## WHY THIS MATTERS\nThe RPC client is the only communication path with the sidecar. It must be reliable and handle all edge cases.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:08:15.809505072Z","created_by":"ubuntu","updated_at":"2026-02-04T03:19:44.915320040Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.2","depends_on_id":"translatorvoiceinputtool-1ao.2","type":"blocks","created_at":"2026-02-04T03:19:44.816438500Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.2","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:08:15.809505072Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.2","depends_on_id":"translatorvoiceinputtool-t89.1","type":"blocks","created_at":"2026-02-04T03:19:44.915240472Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.3","title":"M2.3: Capability detection module","description":"Detect platform capabilities and compute effective modes for hotkey and injection.\n\n## ACCEPTANCE CRITERIA\n- Detects Wayland vs X11 on Linux\n- Checks for XDG Desktop Portal GlobalShortcuts availability\n- Computes effective hotkey mode (hold vs toggle)\n- Computes effective injection mode (clipboard_paste vs clipboard_only)\n- Provides reason strings for why each effective mode was chosen\n- Exposes to UI for Settings and Diagnostics\n\n## IMPLEMENTATION NOTES\nFile: src-tauri/src/capabilities.rs\n\n## CAPABILITY CHECKS\n\n### Linux Display Server\n```rust\nfn detect_display_server() -> DisplayServer {\n    if env::var(\"WAYLAND_DISPLAY\").is_ok() {\n        DisplayServer::Wayland\n    } else if env::var(\"DISPLAY\").is_ok() {\n        DisplayServer::X11\n    } else {\n        DisplayServer::Unknown\n    }\n}\n```\n\n### Wayland Portal Check\n```rust\nasync fn check_portal_shortcuts() -> bool {\n    // Use zbus to query org.freedesktop.portal.GlobalShortcuts\n    // Returns true if portal exists and supports shortcuts\n}\n```\n\n### macOS Permissions\n```rust\nfn check_accessibility_permission() -> bool {\n    // Use CGPreflightListenEventAccess or similar\n}\nfn check_microphone_permission() -> bool {\n    // Use AVFoundation authorization status\n}\n```\n\n## EFFECTIVE MODE COMPUTATION\n\n### Hotkey Mode\n- Windows: hold (reliable key-up)\n- macOS: hold if accessibility granted, else blocked\n- Linux X11: hold (reliable key-up)\n- Linux Wayland: toggle (portal-based, no key-up)\n\n### Injection Mode\n- Windows: clipboard_paste (SendInput works)\n- macOS: clipboard_paste if accessibility granted\n- Linux X11: clipboard_paste (xdotool works)\n- Linux Wayland: clipboard_only (no keystroke synthesis)\n\n## REASON STRINGS\n```rust\npub struct EffectiveMode {\n    pub configured: HotkeyMode,\n    pub effective: HotkeyMode,\n    pub reason: String,  // \"Wayland does not support key release events\"\n}\n```\n\n## API FOR UI\n```rust\n#[tauri::command]\npub fn get_capabilities() -> Capabilities {\n    Capabilities {\n        hotkey: EffectiveMode { ... },\n        injection: EffectiveMode { ... },\n        permissions: PermissionStatus { ... },\n    }\n}\n```\n\n## WHY THIS MATTERS\nUsers need to understand why the app behaves differently on their system. Clear capability detection enables accurate UI feedback.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:08:34.134785259Z","created_by":"ubuntu","updated_at":"2026-02-04T03:19:45.032778996Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.3","depends_on_id":"translatorvoiceinputtool-1ao.4","type":"blocks","created_at":"2026-02-04T03:19:45.032680272Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.3","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:08:34.134785259Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.4","title":"M2.4: Recording controller with Rust-authoritative session IDs","description":"Implement recording state machine with proper session management.\n\n## ACCEPTANCE CRITERIA\n- Rust generates session_id (UUID v4) for each recording\n- Session ID passed to sidecar in recording.start\n- Prevents double-start (already recording → error)\n- Prevents double-stop (not recording → no-op)\n- Stale notifications (wrong session_id) ignored\n- Time-bound behavior enforced with configurable defaults\n- Cancel support via hotkey (double-tap) or UI button\n\n## STATE MACHINE (RUST-OWNED, SOURCE OF TRUTH)\n```\nStates: idle → loading_model (optional) → recording → transcribing → idle\n                                                   ↘ error ↙\n\nTransitions:\n- idle + hotkey_press → recording (if model ready AND enabled)\n- idle + hotkey_press → error (if model not ready)\n- recording + hotkey_release → transcribing (hold mode)\n- recording + hotkey_press → transcribing (toggle mode)\n- recording + max_duration_reached → transcribing (auto-stop)\n- recording + too_short_release → idle (no-op with user message)\n- recording + cancel_trigger → idle (discard audio, no transcription)\n- transcribing + transcription_complete → idle (inject text)\n- transcribing + transcription_error → error\n- transcribing + timeout → error\n- any + sidecar_crash → error (attempt restart)\n- error + user_action OR auto_recovery → idle\n```\n\n## TIME-BOUND BEHAVIOR (CONFIGURABLE DEFAULTS)\n| Parameter | Default | Hard Limit | Behavior |\n|-----------|---------|------------|----------|\n| max_recording_length | 60s | 300s | Auto-stop and continue to transcription |\n| too_short_threshold | 250ms | N/A | Below this: no-op with \"Recording too short\" message |\n| transcription_timeout | 60s | N/A | No event after stop → error with remediation \"restart sidecar\" |\n\n## IMPLEMENTATION NOTES\nFile: src-tauri/src/recording.rs\n\n## SESSION MANAGEMENT\n```rust\npub struct RecordingController {\n    state: AppState,\n    current_session: Option<SessionId>,\n    focus_signature: Option<FocusSignature>,\n    recording_start_time: Option<Instant>,\n    rpc: RpcClient,\n    config: AppConfig,\n}\n\nimpl RecordingController {\n    pub async fn start(&mut self) -> Result<SessionId> {\n        if self.state != AppState::Idle { \n            return Err(AlreadyRecording); \n        }\n        if !self.model_ready() {\n            return Err(ModelNotReady);\n        }\n        \n        let session_id = Uuid::new_v4().to_string();\n        self.rpc.call(\"recording.start\", json!({ \n            \"session_id\": &session_id,\n            \"device_uid\": self.config.audio.device_uid.as_deref()\n        })).await?;\n        \n        self.current_session = Some(session_id.clone());\n        self.recording_start_time = Some(Instant::now());\n        self.state = AppState::Recording;\n        \n        // Start max-duration timer\n        self.start_max_duration_timer();\n        \n        Ok(session_id)\n    }\n    \n    pub async fn stop(&mut self) -> Result<StopResult> {\n        let session = self.current_session.as_ref().ok_or(NotRecording)?;\n        let duration = self.recording_start_time.unwrap().elapsed();\n        \n        // Check too-short threshold\n        if duration < Duration::from_millis(self.config.too_short_threshold_ms as u64) {\n            self.current_session = None;\n            self.state = AppState::Idle;\n            return Ok(StopResult::TooShort);\n        }\n        \n        // Capture focus for Focus Guard (before stopping)\n        self.focus_signature = Some(capture_focus());\n        \n        self.rpc.call(\"recording.stop\", json!({ \"session_id\": session })).await?;\n        self.state = AppState::Transcribing;\n        \n        // Start transcription timeout timer\n        self.start_transcription_timeout();\n        \n        Ok(StopResult::Transcribing)\n    }\n    \n    pub async fn cancel(&mut self) -> Result<()> {\n        let session = self.current_session.as_ref().ok_or(NotRecording)?;\n        \n        self.rpc.call(\"recording.cancel\", json!({ \"session_id\": session })).await?;\n        \n        self.current_session = None;\n        self.focus_signature = None;\n        self.recording_start_time = None;\n        self.state = AppState::Idle;\n        \n        Ok(())\n    }\n}\n```\n\n## CANCEL TRIGGERS\nRecording can be cancelled (audio discarded, no transcription) via:\n\n1. **Hotkey double-tap (toggle mode)**: Two quick presses within 300ms\n   - First press starts recording\n   - Second quick press (< 300ms) cancels instead of stopping\n   - Longer gap between presses → normal stop\n\n2. **UI cancel button**: When settings UI is open during recording\n   - Shows \"Cancel\" button in status area\n   - Calls recording.cancel command\n\n3. **Escape key** (optional, configurable):\n   - When recording, pressing Escape cancels\n   - Disabled by default (avoid accidental cancels)\n\n```rust\nfn on_toggle_hotkey(&mut self) {\n    let now = Instant::now();\n    let since_last_press = now.duration_since(self.last_press_time);\n    self.last_press_time = now;\n    \n    if self.state == AppState::Recording {\n        if since_last_press < Duration::from_millis(300) {\n            // Double-tap detected: cancel\n            log::info!(\"Double-tap cancel detected\");\n            self.cancel().await;\n        } else {\n            // Normal stop\n            self.stop().await;\n        }\n    } else {\n        self.start().await;\n    }\n}\n```\n\n## MAX DURATION AUTO-STOP\n```rust\nfn start_max_duration_timer(&self) {\n    let session = self.current_session.clone();\n    let max_duration = Duration::from_secs(self.config.max_recording_length as u64);\n    \n    tokio::spawn(async move {\n        tokio::time::sleep(max_duration).await;\n        if self.current_session == session && self.state == AppState::Recording {\n            log::info!(\"Max recording duration reached ({:?}), auto-stopping\", max_duration);\n            self.stop().await;\n        }\n    });\n}\n```\n\n## NOTIFICATION HANDLING\n```rust\nfn on_transcription_complete(&mut self, event: TranscriptionComplete) {\n    // Ignore stale notifications (wrong session ID)\n    if Some(&event.session_id) != self.current_session.as_ref() {\n        log::warn!(\"Ignoring stale transcription for session {}\", event.session_id);\n        return;\n    }\n    \n    self.cancel_transcription_timeout();\n    \n    // Inject text (with Focus Guard check)\n    let result = self.inject_text(&event.text).await;\n    \n    // Record in history\n    self.history.push(TranscriptEntry {\n        id: Uuid::new_v4().to_string(),\n        text: event.text,\n        timestamp: Utc::now(),\n        audio_duration_ms: event.audio_duration_ms,\n        transcription_duration_ms: event.duration_ms,\n        injection_result: result,\n    });\n    \n    self.current_session = None;\n    self.focus_signature = None;\n    self.state = AppState::Idle;\n}\n\nfn on_transcription_timeout(&mut self) {\n    log::error!(\"Transcription timeout - no response from sidecar\");\n    self.state = AppState::Error;\n    self.emit_error(UserError {\n        title: \"Transcription Failed\",\n        message: \"No response from transcription service. Click to restart.\",\n        action: Action::RestartSidecar,\n    });\n}\n```\n\n## SERIALIZATION OF INJECTIONS\n- Only one transcription can be injecting at a time\n- Queue if multiple complete simultaneously (unlikely but possible)\n- Use Mutex<InjectionQueue> to serialize\n\n```rust\nstatic INJECTION_MUTEX: Lazy<Mutex<()>> = Lazy::new(|| Mutex::new(()));\n\nasync fn inject_text(&self, text: &str) -> InjectionResult {\n    let _guard = INJECTION_MUTEX.lock().await;\n    // ... perform injection\n}\n```\n\n## TEST REQUIREMENTS\n- Unit test: state machine transitions (all valid paths)\n- Unit test: session ID generation (UUID format)\n- Unit test: session ID correlation (reject wrong session)\n- Unit test: stale notification rejection\n- Unit test: max duration auto-stop\n- Unit test: too-short recording handling (< 250ms)\n- Unit test: transcription timeout handling\n- Unit test: cancel flow (audio discarded)\n- Unit test: double-tap cancel detection\n- Unit test: focus signature capture timing\n- Unit test: injection serialization (concurrent calls queue)\n- Integration test: full flow with mock sidecar\n\n## WHY THIS MATTERS\nSession IDs prevent mis-matching transcriptions to recordings. The state machine ensures predictable behavior. Cancel support lets users abort mistakes. Time-bound behaviors provide guardrails for edge cases.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:08:53.961266511Z","created_by":"ubuntu","updated_at":"2026-02-04T04:45:25.158627575Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.4","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:08:53.961266511Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.4","depends_on_id":"translatorvoiceinputtool-t89.14","type":"blocks","created_at":"2026-02-04T03:50:38.099648679Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.4","depends_on_id":"translatorvoiceinputtool-t89.2","type":"blocks","created_at":"2026-02-04T03:19:45.145168292Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.4","depends_on_id":"translatorvoiceinputtool-t89.3","type":"blocks","created_at":"2026-02-04T03:19:45.251504594Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.5","title":"M2.5: Text injection with Focus Guard and safety checks","description":"Implement clipboard paste injection with Focus Guard to prevent mis-injection.\n\n## ACCEPTANCE CRITERIA\n- Default injection: clipboard paste (set clipboard → delay → paste shortcut)\n- Optional clipboard restore after injection\n- Configurable injection suffix (\"\", \" \", \"\\n\")\n- Focus Guard (default ON): capture focus at stop, validate at inject\n- If focus changed: clipboard-only + warning\n- Never inject into OpenVoicy itself (self-injection prevention)\n- Unicode text injection works correctly\n- Injection serialized (never interleave transcripts)\n\n## IMPLEMENTATION NOTES\nFiles:\n- src-tauri/src/injection.rs\n- src-tauri/src/focus.rs\n\n## INJECTION FLOW\n1. Capture focus signature at recording.stop time\n2. Receive transcription text\n3. Apply injection suffix (default \" \")\n4. Validate focus signature matches (Focus Guard)\n5. Check not self-injection (OpenVoicy window focused)\n6. If mismatch OR self-injection: clipboard-only + warning + return reason\n7. Set clipboard text (with suffix appended)\n8. Wait configurable delay (default 40ms, clamp 10-500ms)\n9. Synthesize paste shortcut (Ctrl+V / Cmd+V)\n10. Optionally restore previous clipboard\n11. Record result in transcript history\n\n## FOCUS GUARD IMPLEMENTATION\n```rust\npub struct FocusSignature {\n    window_id: String,      // Platform-specific window identifier\n    process_name: String,   // For OpenVoicy self-detection\n    app_name: String,       // Human-readable app name for logging\n    captured_at: Instant,\n}\n\npub fn capture_focus() -> FocusSignature {\n    // Platform-specific: get foreground window info\n}\n\npub fn validate_focus(expected: &FocusSignature) -> FocusValidation {\n    let current = capture_focus();\n    if is_self_focused(&current) {\n        FocusValidation::SelfFocused\n    } else if current.window_id != expected.window_id {\n        FocusValidation::Changed { \n            from: expected.app_name.clone(), \n            to: current.app_name.clone() \n        }\n    } else {\n        FocusValidation::Same\n    }\n}\n\nfn is_self_focused(sig: &FocusSignature) -> bool {\n    sig.process_name.to_lowercase().contains(\"openvoicy\")\n}\n```\n\n## SELF-INJECTION PREVENTION\nOpenVoicy MUST NOT inject into its own settings window. This prevents:\n- Transcript appearing in settings text fields\n- Confusion when testing with settings open\n- Recursive paste loops\n\nDetection:\n- Check process name for \"openvoicy\" (case-insensitive)\n- On macOS: check bundle identifier\n- On Windows: check process path\n\nBehavior when self-focused:\n- Copy text to clipboard (for user to paste manually)\n- Show warning notification: \"Settings window focused. Text copied to clipboard.\"\n- Log event with reason\n\n## CLIPBOARD OPERATIONS\n```rust\nasync fn inject_with_paste(text: &str, config: &InjectionConfig) -> InjectionResult {\n    let previous_clipboard = if config.restore_clipboard {\n        Some(get_clipboard()?)\n    } else {\n        None\n    };\n    \n    // Serialize injections\n    let _guard = INJECTION_MUTEX.lock().await;\n    \n    clipboard::set_text(&format!(\"{}{}\", text, config.suffix))?;\n    sleep(Duration::from_millis(config.paste_delay_ms as u64)).await;\n    synthesize_paste()?;\n    \n    if let Some(prev) = previous_clipboard {\n        // Small delay before restore to let paste complete\n        sleep(Duration::from_millis(50)).await;\n        clipboard::set_text(&prev)?;\n    }\n    \n    InjectionResult::Injected\n}\n```\n\n## PASTE SHORTCUT BY PLATFORM\n- Windows: SendInput with VK_CONTROL + VK_V\n- macOS: CGEvent with Cmd+V\n- Linux X11: xdotool or XTestFakeKeyEvent\n- Linux Wayland: clipboard-only (no keystroke synthesis possible)\n\n## CONFIGURATION (with defaults)\n- paste_delay_ms: u32 (default 40, clamp 10-500)\n- restore_clipboard: bool (default true)\n- injection_suffix: String (default \" \" - single space)\n- focus_guard_enabled: bool (default true)\n\n## CLIPBOARD-ONLY MODE REASONS (tracked in history)\n- \"Focus changed from [app1] to [app2]\"\n- \"OpenVoicy settings window focused\"\n- \"Wayland does not support keystroke injection\"\n- \"Accessibility permission not granted\" (macOS)\n- \"Paste synthesis failed: [error]\"\n\n## TEST REQUIREMENTS\n- Unit test: Focus signature capture and comparison\n- Unit test: Self-injection detection (various process name formats)\n- Unit test: Clipboard-only fallback when focus changed\n- Unit test: Clipboard restore timing\n- Unit test: Unicode text handling (emoji, CJK, RTL)\n- Unit test: Suffix application (\"\", \" \", \"\\n\")\n- Unit test: Paste delay clamping (min 10, max 500)\n- Unit test: Injection serialization (concurrent calls queue)\n- Integration test: actual injection on X11 (where available)\n- Mock test: macOS accessibility permission denial\n\n## WHY THIS MATTERS\nFocus Guard prevents the frustrating scenario where transcription appears in the wrong window because the user switched apps during transcription. Self-injection prevention avoids confusing behavior when the settings window is focused.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:09:13.105049618Z","created_by":"ubuntu","updated_at":"2026-02-04T04:39:37.276979726Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.5","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:09:13.105049618Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.5","depends_on_id":"translatorvoiceinputtool-t89.4","type":"blocks","created_at":"2026-02-04T03:19:54.240168177Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.6","title":"M2.6: Transcript history ring buffer","description":"Implement in-memory transcript history for recent transcriptions.\n\n## ACCEPTANCE CRITERIA\n- Stores last 20 transcripts (configurable)\n- No disk persistence in MVP (privacy by default)\n- Tray menu \"Copy last transcript\" works without UI\n- History includes metadata: timestamp, injected?, clipboard_only_reason?, error?\n- History accessible via Tauri command for UI\n\n## IMPLEMENTATION NOTES\nFile: src-tauri/src/history.rs\n\n## DATA STRUCTURE\n```rust\npub struct TranscriptEntry {\n    pub id: Uuid,\n    pub text: String,\n    pub timestamp: DateTime<Utc>,\n    pub audio_duration_ms: u32,\n    pub transcription_duration_ms: u32,\n    pub injection_result: InjectionResult,\n}\n\npub enum InjectionResult {\n    Injected,\n    ClipboardOnly { reason: String },\n    Error { message: String },\n}\n\npub struct TranscriptHistory {\n    entries: VecDeque<TranscriptEntry>,\n    max_size: usize,\n}\n```\n\n## RING BUFFER SEMANTICS\n```rust\nimpl TranscriptHistory {\n    pub fn push(&mut self, entry: TranscriptEntry) {\n        if self.entries.len() >= self.max_size {\n            self.entries.pop_front();\n        }\n        self.entries.push_back(entry);\n    }\n    \n    pub fn last(&self) -> Option<&TranscriptEntry> {\n        self.entries.back()\n    }\n    \n    pub fn all(&self) -> impl Iterator<Item = &TranscriptEntry> {\n        self.entries.iter().rev()  // Newest first\n    }\n}\n```\n\n## TAURI COMMANDS\n```rust\n#[tauri::command]\npub fn get_history() -> Vec<TranscriptEntry>;\n\n#[tauri::command]\npub fn copy_transcript(id: Uuid) -> Result<()>;\n\n#[tauri::command]\npub fn copy_last_transcript() -> Result<Option<String>>;\n```\n\n## TRAY INTEGRATION\n- \"Copy last transcript\" menu item\n- Grayed out if history empty\n- Shows toast/notification on copy\n\n## PRIVACY CONSIDERATIONS\n- History cleared on app quit\n- No disk persistence\n- Diagnostics export excludes transcript text\n- Future: opt-in persistence with explicit privacy messaging\n\n## WHY THIS MATTERS\nUsers often want to access recent transcriptions without keeping the UI open. The tray menu provides quick access.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:09:29.105075986Z","created_by":"ubuntu","updated_at":"2026-02-04T04:39:44.943244091Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.6","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:09:29.105075986Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.6","depends_on_id":"translatorvoiceinputtool-t89.4","type":"blocks","created_at":"2026-02-04T03:19:54.340892619Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.6","depends_on_id":"translatorvoiceinputtool-t89.5","type":"blocks","created_at":"2026-02-04T04:39:44.943174572Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.7","title":"M2.7: Global hotkey handling + audible cues","description":"Implement global hotkey registration with hold/toggle modes and audio feedback.\n\n## ACCEPTANCE CRITERIA\n- Hold mode: press to start, release to stop (where reliable key-up available)\n- Toggle mode: press to start, press again to stop (fallback/default on Wayland)\n- UI shows effective mode with reason (e.g., \"Toggle mode (Wayland limitation)\")\n- Second hotkey: \"Copy last transcript\" (default Ctrl+Shift+V, enabled by default)\n- Audio cues: start/stop/error sounds (default ON, configurable)\n- Debounce OS auto-repeat (ignore repeated key-down while recording)\n- Wayland: integrate with XDG Desktop Portal GlobalShortcuts when available\n- Hotkeys ignored when app is disabled/paused (enabled=false)\n\n## IMPLEMENTATION NOTES\nFile: src-tauri/src/hotkey.rs\n\n## HOTKEY REGISTRATION BY PLATFORM\n\n### Windows\n- RegisterHotKey API\n- Reliable key-down and key-up events\n- Hold mode recommended as default\n- No special permissions required\n\n### macOS\n- CGEventTap (requires Accessibility permission)\n- Reliable key-down and key-up events\n- Hold mode recommended as default\n- Must handle permission request/denial gracefully\n- Show \"Open Settings\" button when denied\n\n### Linux X11\n- XGrabKey via X11 grabs\n- Reliable key-down and key-up events\n- Hold mode recommended as default\n- No special permissions typically\n\n### Linux Wayland (CRITICAL)\nWayland does NOT allow applications to grab global shortcuts directly.\nUse XDG Desktop Portal GlobalShortcuts interface:\n\n```rust\n// Check for portal availability\nasync fn check_portal_shortcuts() -> bool {\n    // Use zbus to query org.freedesktop.portal.GlobalShortcuts\n    // Returns true if portal exists and responds\n}\n\n// Register via portal\nasync fn register_portal_shortcut(shortcut: &str) -> Result<()> {\n    // 1. Create session with portal\n    // 2. Request shortcut binding\n    // 3. Portal shows user confirmation dialog\n    // 4. Listen for Activated signal\n}\n```\n\n**Wayland limitations:**\n- Portal typically provides toggle-like behavior (Activated signal only, no Released)\n- Some compositors may not implement the portal (GNOME does, others vary)\n- User must explicitly approve shortcut in a system dialog\n- Fall back to toggle mode when key-up is not reliable\n- Document in KNOWN_LIMITATIONS.md\n\n## HOLD MODE IMPLEMENTATION\n```rust\nfn on_key_down(&mut self) {\n    if !self.state.is_enabled() {\n        return;  // Paused, ignore\n    }\n    if self.recording {\n        return;  // Debounce auto-repeat\n    }\n    if let Err(e) = self.state.can_start_recording() {\n        log::warn!(\"Cannot start recording: {:?}\", e);\n        self.play_sound(Sound::Error);\n        return;\n    }\n    self.recording = true;\n    self.play_sound(Sound::Start);\n    self.controller.start().await;\n}\n\nfn on_key_up(&mut self) {\n    if !self.recording {\n        return;\n    }\n    self.recording = false;\n    self.play_sound(Sound::Stop);\n    self.controller.stop().await;\n}\n```\n\n## TOGGLE MODE IMPLEMENTATION\n```rust\nfn on_key_down(&mut self) {\n    if !self.state.is_enabled() {\n        return;  // Paused, ignore\n    }\n    if self.recording {\n        self.recording = false;\n        self.play_sound(Sound::Stop);\n        self.controller.stop().await;\n    } else {\n        if let Err(e) = self.state.can_start_recording() {\n            log::warn!(\"Cannot start recording: {:?}\", e);\n            self.play_sound(Sound::Error);\n            return;\n        }\n        self.recording = true;\n        self.play_sound(Sound::Start);\n        self.controller.start().await;\n    }\n}\n// No on_key_up handler needed for toggle mode\n```\n\n## AUDIO CUES\n- Start: short \"beep\" or click sound (~100ms)\n- Stop: different \"beep\" confirming recording ended (~100ms)\n- Error: distinct error tone (~200ms)\n- Sounds bundled in app resources (src-tauri/sounds/)\n- Volume respects system settings (platform audio APIs)\n- Configurable: audio_cues_enabled boolean (default true)\n\nSound files:\n- src-tauri/sounds/start.wav (or .mp3/.ogg)\n- src-tauri/sounds/stop.wav\n- src-tauri/sounds/error.wav\n\n```rust\nfn play_sound(&self, sound: Sound) {\n    if !self.config.audio_cues_enabled {\n        return;\n    }\n    // Use rodio or kira for cross-platform audio playback\n    match sound {\n        Sound::Start => play_bundled_sound(\"start.wav\"),\n        Sound::Stop => play_bundled_sound(\"stop.wav\"),\n        Sound::Error => play_bundled_sound(\"error.wav\"),\n    }\n}\n```\n\n## SECOND HOTKEY: COPY LAST\nDefault: Ctrl+Shift+V (configurable)\nAction: copy last transcript to clipboard + toast notification\nWorks even when paused (enabled=false) - this is intentional!\n\n```rust\nfn on_copy_last_hotkey(&self) {\n    if let Some(last) = self.history.last() {\n        clipboard::set_text(&last.text)?;\n        self.show_notification(\"Copied\", &truncate(&last.text, 50));\n    } else {\n        self.show_notification(\"No transcripts\", \"No recent transcriptions to copy\");\n    }\n}\n```\n\n## HOTKEY CONFLICT HANDLING\n- Detect if hotkey already registered by another app\n- Surface error in UI with remediation: \"Hotkey X in use. Click to change.\"\n- Suggest alternative hotkey\n- On Wayland: portal handles conflicts via user dialog\n- Store last successful hotkey to revert to on conflict\n\n## CONFIGURATION\n- primary_hotkey: String (default \"Ctrl+Shift+Space\")\n- copy_last_hotkey: String (default \"Ctrl+Shift+V\")\n- hotkey_mode: \"hold\" | \"toggle\" (default \"hold\", but effective may differ by platform)\n- audio_cues_enabled: bool (default true)\n\n## EFFECTIVE MODE COMPUTATION\n(Integrates with capabilities.rs)\n- Windows: hold (always)\n- macOS: hold if accessibility granted, else blocked\n- Linux X11: hold (always)\n- Linux Wayland with portal: toggle (portal does not reliably provide key-up)\n- Linux Wayland without portal: blocked or very limited\n\n```rust\nfn compute_effective_mode() -> EffectiveMode {\n    let configured = config.hotkey_mode;\n    let (effective, reason) = match platform() {\n        Platform::Windows => (configured, None),\n        Platform::MacOS if accessibility_granted() => (configured, None),\n        Platform::MacOS => (HotkeyMode::Blocked, Some(\"Accessibility permission required\")),\n        Platform::LinuxX11 => (configured, None),\n        Platform::LinuxWayland if portal_available() => \n            (HotkeyMode::Toggle, Some(\"Wayland portal only supports toggle mode\")),\n        Platform::LinuxWayland => \n            (HotkeyMode::Blocked, Some(\"No shortcut portal available\")),\n    };\n    EffectiveMode { configured, effective, reason }\n}\n```\n\n## AUTO-REPEAT DEBOUNCING\nOS keyboard repeat can cause rapid key-down events when holding a key.\nPrevent multiple recordings by tracking key-down state:\n```rust\nlet key_is_down = AtomicBool::new(false);\n\nfn on_key_down(&mut self) {\n    if self.key_is_down.swap(true, Ordering::SeqCst) {\n        return;  // Already down, this is auto-repeat\n    }\n    // ... start recording\n}\n\nfn on_key_up(&mut self) {\n    if !self.key_is_down.swap(false, Ordering::SeqCst) {\n        return;  // Was not down (shouldn't happen)\n    }\n    // ... stop recording\n}\n```\n\n## TEST REQUIREMENTS\n- Unit test: hold mode start/stop sequence\n- Unit test: toggle mode toggle behavior\n- Unit test: auto-repeat debouncing (multiple key-down, one key-up)\n- Unit test: paused state (enabled=false, hotkey ignored)\n- Unit test: copy last transcript hotkey (works when paused)\n- Unit test: audio cue playback (mock audio system)\n- Unit test: hotkey conflict detection\n- Unit test: effective mode computation for each platform (mock environment)\n- Unit test: Wayland portal availability check (mock D-Bus)\n- Integration test: actual hotkey registration on each platform (manual)\n- Test with different keyboard layouts (special characters)\n\n## WHY THIS MATTERS\nGlobal hotkeys are the primary interaction method. They must work reliably across platforms without requiring the UI to be visible. The Wayland portal integration is essential for modern Linux desktops that default to Wayland.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:09:55.945994540Z","created_by":"ubuntu","updated_at":"2026-02-04T04:44:44.900695677Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.7","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:09:55.945994540Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.7","depends_on_id":"translatorvoiceinputtool-t89.14","type":"blocks","created_at":"2026-02-04T03:50:38.196506386Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.7","depends_on_id":"translatorvoiceinputtool-t89.4","type":"blocks","created_at":"2026-02-04T03:19:54.435965316Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.8","title":"M2.8: Model orchestration on startup","description":"Implement proactive model initialization with status tracking.\n\n## ACCEPTANCE CRITERIA\n- On startup, Rust calls model.get_status\n- If model missing, triggers asr.initialize in background\n- Progress surfaced via tray icon + UI status\n- Tray shows downloading/verifying states via loading_model\n- Model status cached and updated on notifications\n- User can trigger manual download via UI action\n\n## IMPLEMENTATION NOTES\nFile: src-tauri/src/model.rs\n\n## STARTUP FLOW\n```rust\nasync fn init_model_on_startup(&self) {\n    let status = self.rpc.call(\"model.get_status\", json\\!({})).await?;\n    \n    match status.status.as_str() {\n        \"ready\" => {\n            self.model_status = ModelStatus::Ready;\n            log::info\\!(\"Model ready\");\n        }\n        \"missing\" | \"error\" => {\n            self.model_status = ModelStatus::Downloading;\n            self.trigger_model_init().await;\n        }\n        _ => {\n            log::warn\\!(\"Unexpected model status: {}\", status.status);\n        }\n    }\n}\n```\n\n## BACKGROUND INITIALIZATION\n```rust\nasync fn trigger_model_init(&self) {\n    self.set_state(AppState::LoadingModel);\n    \n    match self.rpc.call(\"asr.initialize\", json\\!({\n        \"model_id\": \"parakeet-tdt-0.6b-v3\",\n        \"device_pref\": \"auto\"\n    })).await {\n        Ok(result) => {\n            self.model_status = ModelStatus::Ready;\n            self.set_state(AppState::Idle);\n        }\n        Err(e) => {\n            self.model_status = ModelStatus::Error(e.to_string());\n            self.set_state(AppState::Error);\n        }\n    }\n}\n```\n\n## PROGRESS TRACKING\nSubscribe to event.status_changed notifications:\n```rust\nfn on_status_changed(&mut self, event: StatusChanged) {\n    if let Some(progress) = event.progress {\n        self.download_progress = Some(progress);\n        self.emit_to_ui(\"model_progress\", progress);\n    }\n    if let Some(model) = event.model {\n        self.model_status = model;\n    }\n}\n```\n\n## TRAY ICON STATES\n- Idle: default icon\n- LoadingModel: animated download/loading icon\n- Recording: red/active icon\n- Transcribing: processing icon\n- Error: warning icon\n\n## UI COMMANDS\n```rust\n#[tauri::command]\npub fn get_model_status() -> ModelStatus;\n\n#[tauri::command]\npub async fn download_model() -> Result<()>;\n\n#[tauri::command]\npub async fn purge_model_cache() -> Result<()>;\n```\n\n## WHY THIS MATTERS\nProactive model initialization prevents the first transcription from being unexpectedly slow. Users see progress and know the app is preparing.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:10:15.505923958Z","created_by":"ubuntu","updated_at":"2026-02-04T03:19:54.522222876Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.8","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:10:15.505923958Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.8","depends_on_id":"translatorvoiceinputtool-t89.2","type":"blocks","created_at":"2026-02-04T03:19:54.522150602Z","created_by":"ubuntu"}]}
{"id":"translatorvoiceinputtool-t89.9","title":"M2.9: Config persistence with migrations","description":"Implement atomic configuration storage with versioned migrations.\n\n## ACCEPTANCE CRITERIA\n- Atomic config writes (write temp, rename)\n- Corruption fallback (regenerate defaults if parse fails)\n- Config schema versioned with migration support\n- Microphone selection persists by device_uid (not index!)\n- Tests with temp directories verify persistence\n- Default generation tested\n- All config fields documented with types and defaults\n\n## IMPLEMENTATION NOTES\nFile: src-tauri/src/config.rs\n\n## CONFIG LOCATION\n- macOS: ~/Library/Application Support/OpenVoicy/config.json\n- Windows: %APPDATA%/OpenVoicy/config.json\n- Linux: ~/.config/OpenVoicy/config.json\n\n## COMPLETE CONFIG SCHEMA (v1)\n```rust\n#[derive(Serialize, Deserialize, Default)]\npub struct AppConfig {\n    #[serde(default = \"default_schema_version\")]\n    pub schema_version: u32,  // Current: 1\n    \n    #[serde(default)]\n    pub audio: AudioConfig,\n    \n    #[serde(default)]\n    pub hotkeys: HotkeyConfig,\n    \n    #[serde(default)]\n    pub injection: InjectionConfig,\n    \n    #[serde(default)]\n    pub replacements: Vec<ReplacementRule>,\n    \n    #[serde(default)]\n    pub ui: UiConfig,\n    \n    #[serde(default)]\n    pub presets: PresetsConfig,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct AudioConfig {\n    pub device_uid: Option<String>,    // Stable UID, not index! None = default device\n    pub audio_cues_enabled: bool,      // Default: true\n}\n\nimpl Default for AudioConfig {\n    fn default() -> Self {\n        Self {\n            device_uid: None,          // Use system default\n            audio_cues_enabled: true,  // Sounds on by default\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize)]\npub struct HotkeyConfig {\n    pub primary: String,               // Default: \"Ctrl+Shift+Space\"\n    pub copy_last: String,             // Default: \"Ctrl+Shift+V\"\n    pub mode: HotkeyMode,              // Default: Hold\n}\n\nimpl Default for HotkeyConfig {\n    fn default() -> Self {\n        Self {\n            primary: \"Ctrl+Shift+Space\".into(),\n            copy_last: \"Ctrl+Shift+V\".into(),\n            mode: HotkeyMode::Hold,\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize)]\npub struct InjectionConfig {\n    pub paste_delay_ms: u32,           // Default: 40, clamp 10-500\n    pub restore_clipboard: bool,       // Default: true\n    pub suffix: String,                // Default: \" \" (single space)\n    pub focus_guard_enabled: bool,     // Default: true\n}\n\nimpl Default for InjectionConfig {\n    fn default() -> Self {\n        Self {\n            paste_delay_ms: 40,\n            restore_clipboard: true,\n            suffix: \" \".into(),        // Space after injection\n            focus_guard_enabled: true, // Protect against wrong-window injection\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize)]\npub struct UiConfig {\n    pub show_on_startup: bool,         // Default: true (show settings on first run)\n    pub window_width: u32,             // Default: 600\n    pub window_height: u32,            // Default: 500\n}\n\nimpl Default for UiConfig {\n    fn default() -> Self {\n        Self {\n            show_on_startup: true,     // First run shows settings\n            window_width: 600,\n            window_height: 500,\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize)]\npub struct PresetsConfig {\n    pub enabled_presets: Vec<String>,  // IDs of enabled preset rule sets\n}\n\nimpl Default for PresetsConfig {\n    fn default() -> Self {\n        Self {\n            enabled_presets: vec![],   // No presets enabled by default\n        }\n    }\n}\n\nfn default_schema_version() -> u32 { 1 }\n```\n\n## ATOMIC WRITES\n```rust\npub fn save_config(config: &AppConfig) -> Result<()> {\n    let path = config_path();\n    let temp = path.with_extension(\"json.tmp\");\n    \n    // Ensure parent directory exists\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent)?;\n    }\n    \n    let json = serde_json::to_string_pretty(config)?;\n    fs::write(&temp, json)?;\n    fs::rename(&temp, &path)?;  // Atomic on most filesystems\n    \n    Ok(())\n}\n```\n\n## MIGRATION SYSTEM\n```rust\nfn migrate_config(mut config: Value) -> AppConfig {\n    let version = config[\"schema_version\"].as_u64().unwrap_or(0);\n    \n    // Migration v0 → v1: add focus_guard_enabled\n    if version < 1 {\n        config[\"injection\"][\"focus_guard_enabled\"] = json!(true);\n        config[\"schema_version\"] = json!(1);\n        log::info!(\"Migrated config v0 → v1: added focus_guard_enabled\");\n    }\n    \n    // Future migrations go here\n    // if version < 2 { ... }\n    \n    serde_json::from_value(config).unwrap_or_else(|e| {\n        log::error!(\"Config migration failed, using defaults: {}\", e);\n        AppConfig::default()\n    })\n}\n```\n\n## CORRUPTION HANDLING\n```rust\npub fn load_config() -> AppConfig {\n    let path = config_path();\n    \n    match fs::read_to_string(&path) {\n        Ok(content) => {\n            match serde_json::from_str::<Value>(&content) {\n                Ok(value) => migrate_config(value),\n                Err(e) => {\n                    log::error!(\"Config parse error, using defaults: {}\", e);\n                    // Backup corrupt file for debugging\n                    let backup = path.with_extension(\"json.corrupt\");\n                    let _ = fs::rename(&path, &backup);\n                    AppConfig::default()\n                }\n            }\n        }\n        Err(e) if e.kind() == io::ErrorKind::NotFound => {\n            log::info!(\"No config file, using defaults\");\n            AppConfig::default()\n        }\n        Err(e) => {\n            log::error!(\"Config read error, using defaults: {}\", e);\n            AppConfig::default()\n        }\n    }\n}\n```\n\n## VALIDATION\n```rust\nimpl AppConfig {\n    pub fn validate_and_clamp(&mut self) {\n        // Clamp paste delay\n        self.injection.paste_delay_ms = self.injection.paste_delay_ms.clamp(10, 500);\n        \n        // Validate hotkey format (basic check)\n        if self.hotkeys.primary.is_empty() {\n            self.hotkeys.primary = \"Ctrl+Shift+Space\".into();\n        }\n        \n        // Future: validate replacement rules against schema\n    }\n}\n```\n\n## TEST REQUIREMENTS\n- Unit test: default config generation\n- Unit test: save/load roundtrip\n- Unit test: atomic write (temp file created and renamed)\n- Unit test: corrupt file fallback (invalid JSON)\n- Unit test: corrupt file fallback (valid JSON, wrong schema)\n- Unit test: migration v0 → v1\n- Unit test: missing optional fields get defaults\n- Unit test: paste_delay_ms clamping\n- Unit test: device_uid persisted correctly (not numeric index)\n- Integration test: config survives app restart\n- Test with temp directories to avoid polluting real config\n\n## WHY THIS MATTERS\nConfiguration must survive crashes, power loss, and upgrades. Atomic writes and migrations ensure reliability. Explicit defaults ensure predictable behavior.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-04T03:10:33.562849580Z","created_by":"ubuntu","updated_at":"2026-02-04T04:42:32.255803913Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"translatorvoiceinputtool-t89.9","depends_on_id":"translatorvoiceinputtool-1ao.1","type":"blocks","created_at":"2026-02-04T03:19:54.634177261Z","created_by":"ubuntu"},{"issue_id":"translatorvoiceinputtool-t89.9","depends_on_id":"translatorvoiceinputtool-t89","type":"parent-child","created_at":"2026-02-04T03:10:33.562849580Z","created_by":"ubuntu"}]}
